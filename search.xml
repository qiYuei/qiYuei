<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>http2和http3</title>
      <link href="/2020/11/25/http2-he-http3/"/>
      <url>/2020/11/25/http2-he-http3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cookie</title>
      <link href="/2020/11/24/cookie/"/>
      <url>/2020/11/24/cookie/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-cookie"><a href="#什么是-cookie" class="headerlink" title="什么是 cookie"></a>什么是 cookie</h1><p>由于 <code>HTTP</code> 是无状态协议,但是比如一个网站我不可能每打开一个页面都登陆一次吧。总要有一个东西来记录用户的状态~。这时候 <code>cookie</code>就诞生了。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 完整格式如下</span>Set<span class="token operator">-</span>Cookie<span class="token punctuation">:</span> <span class="token string">"name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure"</span></code></pre><p>其中 <code>name=value</code>是一个必填项</p><h2 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h2><p>这里可以设置 cookie 对于哪个域是有效的。值得注意的是这个值可以包含子域。比如 <code>domain=.taobao.com</code>那么他的子域<code>A.taobao.com</code> 又或者是 <code>B.taobao.com</code> 都可以访问。但是如果设置了<code>A.taobao.com</code>那么只有<code>A.taobao.com</code>这个域才能获取到这个 cookie。</p><h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>类似 <code>domain</code> 但是 <code>path</code> 对应得是路径，可以设置<code>/login</code>那这个路径下包括<code>/login/xxx</code>都可以访问到这个 <code>cookie</code>。</p><h2 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h2><p>过期时间，和 <code>max-age</code> 一样都是临时会话的时间。 <code>max-age</code> 是秒数。如果两者同一时间出现则<code>max-age</code>的优先级更高。cookie 的生命周期默认为 <code>session</code>，即浏览器关闭后删除。如果设置了 <code>expires</code>，则由 <code>expires</code> 控制，如果浏览器关闭还没到过期时间，则会保存在硬盘中</p><h2 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h2><p><code>JS脚本</code>是否可以获取（默认可以获取，为<code>false</code>）。如果设置为<code>true</code>则可以有效防止<code>XSS攻击</code>。该属性只能在服务的设置</p><h2 id="Secure"><a href="#Secure" class="headerlink" title="Secure"></a>Secure</h2><p>S 脚本是否可以获取（默认可以获取，为 false)。若为 true，那么 Cookie 只能在 <code>HTTPS</code>连接中传输；若为 false，HTTP、HTTPS 连接都行。</p><h2 id="Samesite"><a href="#Samesite" class="headerlink" title="Samesite"></a>Samesite</h2><ul><li>None 同站请求、跨站请求发送<code>cookie</code>，但是在 chrome80+以后，设置为<code>None</code>需要同时设置<code>Secure</code>，也就意味着必须要<code>https</code>连接。</li><li>Strict 仅发送同站点的请求的 cookie</li><li>Lax Chrome80 后默认为这个值。仅<code>get请求跨站</code>。大多数情况也是不发送第三方 cookie。 包括三种情况：<code>链接，预加载请求，get 表单</code></li></ul><p>设置为 <code>Lax,Strict</code>可以杜绝大部分<code>csrf攻击</code>。</p><img src="/2020/11/24/cookie/1.png" class><h3 id="跨域跨站"><a href="#跨域跨站" class="headerlink" title="跨域跨站"></a>跨域跨站</h3><p>其中<code>同站(same-site)</code>/<code>跨站(cross-site)</code>」和<code>第一方(first-party)</code>/<code>第三方(third-party)</code>是等价的。</p><p>举几个例子，<code>www.taobao.com</code> 和 <code>www.baidu.com</code> 是跨站，<code>www.a.taobao.com</code> 和 <code>www.b.taobao.com</code> 是同站，<code>a.github.io</code> 和 <code>b.github.io</code> 是跨站(注意是跨站)。</p><h3 id="cookie-与-session-的区别"><a href="#cookie-与-session-的区别" class="headerlink" title="cookie 与 session 的区别"></a>cookie 与 session 的区别</h3><p><code>session</code> 是服务端的一种机制，使用类似散列表的数据结构来保存用于用户信息，如登录状态。<br><code>cookie</code> 则可以用于服务端保存登录状态，比如为客户端设置 <code>cookie</code> 来保存 <code>session</code> 对应的 <code>sessionID</code>，下次请求时客户端自动携带 <code>cookie</code>，服务的从中取出 <code>sessionID</code>，在从 <code>session</code> 表中获取用户登录状态及用户信息。</p><h3 id="cookie-和-token-的关系"><a href="#cookie-和-token-的关系" class="headerlink" title="cookie 和 token 的关系"></a>cookie 和 token 的关系</h3><p><code>token</code> 是另一种流行的处理 <code>http</code> 无状态的方式，一般设置在请求头中。当用户登录成功时返回 <code>token</code> 给客户端，客户端再次请求时携带 <code>token</code>，服务端获取 <code>token</code> 后，再从 <code>session</code> 中获取用户信息及登录状态。<br>与 <code>cookie</code> 相比，因为 <code>token</code> 在代码中设置，不会在访问第三方网站时携带 <code>cookie</code>，可以有效避免 <code>csrf</code> 攻击。</p><h3 id="cookie-缺点"><a href="#cookie-缺点" class="headerlink" title="cookie 缺点"></a>cookie 缺点</h3><ul><li><code>cookie</code> 的大小一般被浏览器限制为 <code>4kb</code></li><li>请求自动携带 <code>cookie</code> 其实会造成无效的带宽浪费</li><li>安全问题（csrf 与 xss）</li></ul><h1 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h1><p><code>xss攻击</code>就是跨站脚本攻击。一般可以分为三类，我认为实际上可以分为两类<code>存储型和非存储型</code></p><h3 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h3><p>反射型一般构造在<code>url</code>中。如果服务端中没有做过处理，直接将内容返回给客户端则会触发在<code>url</code>中隐藏的<code>&lt;script&gt;&lt;/script&gt;</code>代码。形如</p><pre class=" language-js"><code class="language-js">www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com<span class="token operator">?</span><span class="token operator">&lt;</span>srcipt<span class="token operator">></span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'xss'</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>但是这样主要还是需要构造<code>url</code>然后去触发。</p><h3 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h3><p>存储型就是将<code>xss攻击</code>保存到数据库中。比如我一个评论中注入恶意代码</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>img onerror<span class="token operator">=</span><span class="token string">"alert('xss')"</span> src<span class="token operator">=</span><span class="token string">""</span><span class="token operator">></span></code></pre><p>这样存储在数据库的攻击危害是最大的。因为每一个见到这个评论的人都会受到攻击。</p><h3 id="DOM-型"><a href="#DOM-型" class="headerlink" title="DOM 型"></a>DOM 型</h3><p><code>DOM型</code>实际上是最难的，因为他需要构造一个带有<code>XSS攻击</code>的 DOM。然后诱导用户去操作才会触发。</p><h3 id="XSS-注入方法"><a href="#XSS-注入方法" class="headerlink" title="XSS 注入方法"></a>XSS 注入方法</h3><p>在 <code>HTML</code> 中内嵌的文本中，恶意内容以 <code>script</code> 标签形成注入。<br>在内联的 <code>JavaScript</code>中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。<br>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。<br>在标签的 <code>href、src</code> 等属性中，包含 <code>javascript:</code> 等可执行代码。<br>在 <code>onload、onerror、onclick</code> 等事件中，注入不受控制代码。<br>在 <code>style</code> 属性和标签中，包含类似 <code>background-image:url(&quot;javascript:...&quot;)</code>; 的代码（新版本浏览器已经可以防范）。<br>在 <code>style</code> 属性和标签中，包含类似 <code>expression(...)</code>的 CSS 表达式代码（新版本浏览器已经可以防范）。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ul><li>对用户提交的可能存在 xss 攻击的地方进行转义，服务端中也需要。</li><li>服务端在<code>http</code>中设置<code>set-cookie:Httponly</code></li><li>用<code>innerText</code>和<code>setAttribute()</code>代替<code>innerHtml</code></li></ul><h1 id="CSRF-攻击"><a href="#CSRF-攻击" class="headerlink" title="CSRF 攻击"></a>CSRF 攻击</h1><p><code>CSRF</code>攻击就是跨站请求伪造，简单点就是我冒用你的身份去做你不知道的事情。<br>比如之前的钓鱼网址就是。比如小明登陆了 A 网站。这时候 A 网站就会有小明的<code>cookie</code>。小明再被我诱导点击我写好<code>document.cookie</code>的空页面。一进入这个页面就会拿到小明的<code>cookie</code>并且去请求 A 网站的接口做一些坏事。因为我用的是小明的<code>cookie</code>这样就是我冒用小明对他造成了一系列损失。</p><h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><ul><li><p>在服务端中设置 SameSite 为<code>LUX</code>,这样因为我的网站是相对于 A 来说是第三方网站。即便是<code>&lt;a&gt;</code>跳转的。请求时也不会携带 cookie。</p></li><li><p>判断请求头中的<code>Origin Header Referer Header</code>检测是否同源。（协议，域名，端口完全相同）</p><p>这两个 Header 在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个 Header 中的域名，确定请求的来源域。<br><code>Origin Header</code>请求的 Header 中会携带 Origin 字段。字段内包含请求的域名（不包含 path 及 query）。<br><code>Referer Header</code>在 HTTP 头中有一个字段叫 Referer，记录了该 HTTP 请求的来源地址。<br>对于 Ajax 请求，图片和 script 等资源请求，Referer 为发起请求的页面地址。对于页面跳转，Referer 为打开页面历史记录的前一个页面地址。因此我们使用 Referer 中链接的 Origin 部分可以得知请求的来源域名。</p></li><li><p>采用<code>token</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试必备系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> cookie </tag>
            
            <tag> xss攻击 </tag>
            
            <tag> csrf攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传统RSA握手和TLS1.2/TLS1.3握手</title>
      <link href="/2020/11/23/chuan-tong-rsa-wo-shou-he-ssl1-2-ssl1-3-wo-shou/"/>
      <url>/2020/11/23/chuan-tong-rsa-wo-shou-he-ssl1-2-ssl1-3-wo-shou/</url>
      
        <content type="html"><![CDATA[<p>上一节中知道大概 <code>HTTPS</code> 是怎么构成的。 <code>SSL</code> (安全套接层)和 <code>TLS</code>(传输层安全) 加上 <code>HTTP</code>。然后也大概演示了 对称加密和非对称加密的优缺点。<br>其实在服务端和客户端交换秘钥的过程中，也在 <code>握手</code>。所以就不单单只有 <code>TCP</code> 的三次握手。</p><p><code>TLS</code> 中有三个版本的握手分别是 <code>TLS1.0</code> , <code>TLS1.1</code>, <code>TLS1.2</code> ,<code>TLS1.3</code>但是由于 <code>TLS1.0</code> 在提案阶段就暴露出一些问题。所以就直接没有继续下去。现在我们常用的是 <code>TLS1.2</code></p><h3 id="TLS1-1-RSA-握手"><a href="#TLS1-1-RSA-握手" class="headerlink" title="TLS1.1(RSA 握手)"></a>TLS1.1(RSA 握手)</h3><p><code>TLS1.1</code> 也就是以前说的 <code>RSA</code>握手。首先得明确的是不管是 <code>TSL 1.X</code>除了 <code>TLS 1.0</code> 之外。他们之间的握手全部都是 <code>混合加密</code>的方式。</p><ul><li><p>客户端会 发送 <code>client-random</code>(随机数) 和 加密方法列表去服务端请求</p></li><li><p>服务端也会随机一个 <code>server-random</code> 和 加密方法 以及 <code>CA证书</code> 至客户端</p></li><li><p>客户端会根据服务端传递过来的 <code>CA证书</code> 去验证。通过则用<code>RSA算法</code>生成一个 <code>pre_random</code>。</p></li><li><p>客户端通过 <code>client-random</code>,<code>server-random</code>,<code>pre_random</code> 通过伪随机函数函数得到 <code>secret</code></p></li><li><p>再将这个<code>pre_random</code>随机数通过证书的公钥发送给服务端.</p></li><li><p>服务端通过 证书的私钥解密 获得一个 <code>pre_random</code>。 然后通过用<code>client-random</code>,<code>server-random</code>,<code>pre_random</code>得到一个 <code>secret</code>.</p></li><li><p>发送一个 <code>确认信号后</code> 开始用 以 <code>secret</code>作为<code>对称加密</code>的秘钥</p></li></ul><img src="/2020/11/23/chuan-tong-rsa-wo-shou-he-ssl1-2-ssl1-3-wo-shou/1.jpg" class><h3 id="TLS1-2-ECDHE-握手"><a href="#TLS1-2-ECDHE-握手" class="headerlink" title="TLS1.2(ECDHE 握手)"></a>TLS1.2(ECDHE 握手)</h3><p><code>ECDHE握手</code>在<code>RSA握手</code>的基础上前两个环节都不变</p><ol><li><p>客户端会 发送 <code>client-random</code>(随机数) 和 加密方法列表去服务端请求</p></li><li><p>服务端也会随机一个 <code>server-random</code> 和 加密方法 以及 <code>CA证书</code> 至客户端</p></li><li><p>客户端会根据服务端传递过来的 <code>CA证书</code> 去验证。通过则用<code>ECDHE算法</code>生成一个 <code>pre_random</code>。<br><code>ECDHE(client_random, server_random) = per_random)</code></p></li><li><p>客户端通过 <code>client-random</code>,<code>server-random</code>,<code>pre_random</code> 通过伪随机函数函数得到 <code>secret</code></p></li><li><p>再将这个<code>pre_random</code>随机数通过证书的公钥发送给服务端.</p></li><li><p>服务端通过 证书的私钥解密 获得一个 <code>pre_random</code>。 然后通过用<code>client-random</code>,<code>server-random</code>,<code>pre_random</code>得到一个 <code>secret</code>.</p></li><li><p>发送一个 <code>确认信号后</code> 开始用 以 <code>secret</code>作为<code>对称加密</code>的秘钥</p></li></ol><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p><code>RSA握手</code> 通过 <code>RSA算法</code> 得到 <code>pre_random</code></p><p><code>ECDHE握手</code> 通过 <code>ECDHE算法</code> 加上 <code>client-random</code>,<code>server-random</code>,得到 <code>pre_random</code></p><p><code>ECDHE握手</code>客户端生成秘钥后，在发送确认消息后，可以直接发送 <code>HTTP报文</code>。而<code>RSA握手</code>需要等待 服务端的确认消息后才可以开始。</p><p>最主要的：RSA 不具备向前安全性，ECDHE 有</p><h4 id="向前安全性"><a href="#向前安全性" class="headerlink" title="向前安全性"></a>向前安全性</h4><p>一句话概括：一次破解并不影响历史信息的性质就是向前安全性。</p><p>比如在<code>RSA握手</code>的过程中，客户端拿到了服务端的公钥，然后用此公钥加密<code>pre_random</code>给服务端。如果此时有第三方有服务端的私钥，并且截获了之前所有报文的时候，那么它就可以破解这段密文并拿到<code>pre_random、client_random、server_random</code>并根据对应的伪随机函数生成<code>secret</code>，即拿到了最终通信的对称密钥，每一个历史报文都能通过这样的方式进行破解。它就不具有向前安全性。</p><p>但是<code>ECDHE在每次握手</code>的时候都会产生一个零时的密钥对(也就是<code>client_params、server_params</code>)，即使第三方有了私钥能破解，但是对之前的历史报文并没有影响。它就具有向前安全性。</p><h3 id="TSL1-3"><a href="#TSL1-3" class="headerlink" title="TSL1.3"></a>TSL1.3</h3><ul><li><p>废除了很多加密算法。其中就包括<code>RSA算法</code></p></li><li><p>通过利用会话复用节省了重新生成秘钥的时间</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试必备系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTPS </tag>
            
            <tag> TSL握手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈HTTPS的对称加密和非对称加密</title>
      <link href="/2020/11/21/qian-tan-https-de-dui-cheng-jia-mi-he-fei-dui-cheng-jia-mi/"/>
      <url>/2020/11/21/qian-tan-https-de-dui-cheng-jia-mi-he-fei-dui-cheng-jia-mi/</url>
      
        <content type="html"><![CDATA[<p>因为 <code>http</code> 是明文传输的缘故,这方面在现如今非常容易被黑客所利用。所以就出了<code>HTTPS</code>这玩意。默认的端口是 <code>443</code>。</p><p><code>https</code>在一定程度上解决了明文传输数据这一诟病。但是对于传输速度来说它可能还没有 <code>http</code> 快。对于传输速度、队头阻塞这些是 <code>http2.0</code> <code>http3.0</code>这两兄弟干的。(小声嘀咕 <code>http2.0</code> 都还没有普及。<code>http3.0</code> 就来了….)。而 <code>https</code>来说只负责数据传输间的安全性。 所以 <code>HTTPS = HTTP+SSL+TLS</code></p><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>对称加密说起来就跟字面意思一样。所谓对称就是使用相同的秘钥来进行加密数据。</p><img src="/2020/11/21/qian-tan-https-de-dui-cheng-jia-mi-he-fei-dui-cheng-jia-mi/1.png" class><p>这里问题就很大了,如果我是黑客，我通过抓包工具,一样可以拿到他们传输的秘钥。这样其实加不加密都没有什么效果。</p><p>优点：因为是对称加密,使用相同的秘钥所以加密的速度就会快</p><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>非对称加密这里呢，服务器会有一套秘钥，他们有公钥和私钥之分。公钥提供给客户端。私钥只留在客户端中。</p><img src="/2020/11/21/qian-tan-https-de-dui-cheng-jia-mi-he-fei-dui-cheng-jia-mi/2.png" class><p>我敲这套理论好像真的可以。理论上是可以的，但实际上非对称加密需要的计算量非常大，对于稍微大一点的数据即使用最快的处理器也非常耗时。</p><h4 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h4><p>前面说了对称加密这个速度快，但是安全性不高。而非对称加密安全性高，但是速度可能会很慢。那不如把它两给结合起来？</p><img src="/2020/11/21/qian-tan-https-de-dui-cheng-jia-mi-he-fei-dui-cheng-jia-mi/3.png" class><p>这样就天衣无缝了哈哈哈哈哈,但是聪明的中间人如果在你第一次请求公钥的时候就把错误的公钥传给你。（也就是说而他拿到了真正的公钥）。 你拿着他的公钥去加密，这个中间人一样可以用他自己的私钥解密。这样还是无法保证安全性。</p><h4 id="CA-证书"><a href="#CA-证书" class="headerlink" title="CA 证书"></a>CA 证书</h4><p>上面混合加密的缺点就是没办法确定,与客户端通信的服务端是不是自己信任的服务端。那这样就找一个双方都信任的方式。<code>CA证书</code>它通过确认服务端的真实身份后。将他的签名加入到 <code>公钥和私钥之中</code>。这样只有 <code>客户端公钥+签名</code> 更够被 <code>服务器中的私钥+签名</code>所解析。那就是找对人了。</p><img src="/2020/11/21/qian-tan-https-de-dui-cheng-jia-mi-he-fei-dui-cheng-jia-mi/4.png" class><p>这样的话就算这个中间人拿到了这个公钥想要去伪造,也会因为这个<code>CA签名</code>不一样。解析不了数据。</p><p>缺点:贵贵贵！！</p><h3 id="中间人有可能篡改证书吗"><a href="#中间人有可能篡改证书吗" class="headerlink" title="中间人有可能篡改证书吗"></a>中间人有可能篡改证书吗</h3><p>假如中间人获取到了 CA 证书，并修改了证书中的域名，但是此时它没有 CA 机构的私钥，所以它无法得到一个新的签名，然后客户端收到</p><p>该篡改的证书后，通过私钥解密出来一个原证书信息的摘要，并且客户端对收到的证书内容生成信息摘要，发现两个信息不一致，就会</p><p>终止通信，防止信息泄露。</p><h3 id="中间人有可能替换证书吗"><a href="#中间人有可能替换证书吗" class="headerlink" title="中间人有可能替换证书吗"></a>中间人有可能替换证书吗</h3><p>假如中间人也有一个 CA 机构颁发的合法的证书，中间人拦截到服务端发送的证书，并将自己的证书发送给客户端，此时客户端就会使用</p><p>中间人证书的公钥进行通信。</p><p>其实该情况是不会发生的，因为在验证的过程中会验证域名，如果访问的域名与证书中的域名不一致就会提示不安全的链接。但是如果</p><p>中间人可以使用你的域名去申请到证书，那就另当别论了，但是这也不会发生，因为证书申请是需要进行信息核实的，并不是可以随意申请的。</p><h3 id="数字签名为什么是对-hash-值进行签名"><a href="#数字签名为什么是对-hash-值进行签名" class="headerlink" title="数字签名为什么是对 hash 值进行签名"></a>数字签名为什么是对 hash 值进行签名</h3><p>其实这只是一个性能问题，因为 hash 值相对于 CA 证书的信息来说是比较短的值，对该值进行加密和解密都会比较快。通常在生成证书的时候也不会在乎这些时间，但是在浏览器进行解密时，如果时间过长，用户可就等不了那么长的时间了。</p><h3 id="HTTPS-必须在每次请求中都要先在-SSL-TLS-层进行握手传输密钥吗"><a href="#HTTPS-必须在每次请求中都要先在-SSL-TLS-层进行握手传输密钥吗" class="headerlink" title="HTTPS 必须在每次请求中都要先在 SSL/TLS 层进行握手传输密钥吗"></a>HTTPS 必须在每次请求中都要先在 SSL/TLS 层进行握手传输密钥吗</h3><p>如果每一次 https 的请求都需要进行 TLS 的握手，TLS 的握手那么复杂，势必会对通信带来较大的延时，这对注重用户体验的网站来说，是不可接受的。那么有什么办法可以避免这种情况吗？</p><p>其实是通过一个 Session Identifier（会话标识符），该 Session ID 是 TLS 握手中生成的 Session ID。服务端可以将 Session ID 协商后的信息存起来，浏览器也可以保存 Session ID，并在后续的 Client Hello 握手中带上它，如果服务端能找到与之匹配的信息，就可以完成一次快速握手。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>HTTPS</code> 在 交换出 <code>对称加密</code> 的秘钥之前用 <code>非对称加密</code></p><p>得到 <code>对称加密的秘钥后</code> 使用 <code>对称加密</code></p>]]></content>
      
      
      <categories>
          
          <category> 面试必备系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML和Css知识梳理</title>
      <link href="/2020/11/09/html-he-css-zhi-shi-shu-li/"/>
      <url>/2020/11/09/html-he-css-zhi-shi-shu-li/</url>
      
        <content type="html"><![CDATA[<h3 id="浏览器的渲染原理"><a href="#浏览器的渲染原理" class="headerlink" title="浏览器的渲染原理"></a>浏览器的渲染原理</h3><p>根据 dom 生成 dom 树,然后根据 css 生成 css 树。然后 dom 树和 css 树生成一棵 render 树，因为节点中可能有 <code>display:none</code>；所以 render 树和 dom 树并不是一一对应的。接着就会遍历渲染书并调用渲染对象的 point()方法将他们的内容显示在屏幕上。注意:浏览器为了更好地用户体验采取渲染一部分就显示一部分。<br>如果渲染的过程中遇到 JS 文件的加载、解析、与执行。则会阻止解析过程,因为 JS 中可能会有对 dom 的一系列操作，所以需要等待 JS 执行完毕,这就会造成长时间的白屏。解决办法就是将 <code>&lt;script&gt;&lt;/script&gt;</code> 放置 body 的下面。<br>或者是 在 <code>&lt;script&gt;&lt;/script&gt;</code> 中加入 <code>async</code> 或者 <code>defer</code>让 JS 异步加载</p><h4 id="defer-和-async"><a href="#defer-和-async" class="headerlink" title="defer 和 async"></a>defer 和 async</h4><p><code>defer</code>异步加载 JS 文件，延迟执行。也就是说加载 JS 时<code>html并未停止解析</code>。两个过程是并行的。在等整个 document 文档解析完再执行 JS 脚本。文档解析完成时，脚本被执行，此时也会触发 domcontentloaded 事件，优先执行脚本</p><p><code>async</code>异步加载 JS 文件但是 它是先加载完就立刻执行所以执行的顺序不一定，也就是说他的执行也会<code>阻塞文档的解析</code></p><h4 id="css-解析为什么会阻碍页面渲染"><a href="#css-解析为什么会阻碍页面渲染" class="headerlink" title="css 解析为什么会阻碍页面渲染"></a>css 解析为什么会阻碍页面渲染</h4><p>首先、css 解析并不会影响 dom 的解析，但是会阻碍页面的渲染</p><p>css 选择器<br>!important &gt; style &gt; id &gt; Class|属性|伪类 &gt; 元素选择器</p><h3 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h3><h4 id="减少回流的操作"><a href="#减少回流的操作" class="headerlink" title="减少回流的操作"></a>减少回流的操作</h4>]]></content>
      
      
      <categories>
          
          <category> 面试必备系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断链表是否有环</title>
      <link href="/2020/10/21/pan-duan-lian-biao-shi-fou-you-huan/"/>
      <url>/2020/10/21/pan-duan-lian-biao-shi-fou-you-huan/</url>
      
        <content type="html"><![CDATA[<p>如何判断一个链表是否是环形链表呢？不管是哪一种环形链表，循环遍历的时候一定是死循环的，<br>那么在链表循环过程中，如果我们不止一次的遇到同一个节点，这个链表就肯定是环形链表。<br>链表有环分两种</p><ul><li>首尾结成环</li><li>尾部与其他节点结成环,统称6子环</li></ul><p>解题方法有 </p><ul><li>快慢指针法 </li><li>哈希表法</li></ul><h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><p>顾名思义就是有两个指针,一个指针指向链表的两个 <code>next</code> 而另外一个指针每次指向一个 <code>next</code></p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> fast <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token keyword">let</span> slow <span class="token operator">=</span> head<span class="token punctuation">.</span>next</code></pre><p>这样 <code>fast</code> 永远比 <code>slow</code> 快一个单位,就好比两个人去跑步,一个人的速度是 <code>2n</code>,一个是 <code>n</code>。如果是在操场上跑步的话总有一个时间点这两人是相遇的。但是如果是在没有环的大马路上,跑到下辈子都不能相遇的。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/*** @{param} head **/</span><span class="token keyword">function</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">let</span> fast <span class="token operator">=</span> head  <span class="token keyword">let</span> slow <span class="token operator">=</span> head  <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">&amp;&amp;</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>      fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next      slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next      <span class="token keyword">if</span><span class="token punctuation">(</span>fast <span class="token operator">===</span> slow<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 如果走出循环了就说明没有相遇</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">}</span></code></pre><h4 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h4><p>哈希表在 <code>JS</code> 中就是使用 <code>ES6</code> 的<code>new Map()</code>,借助这种数据方式的 <code>key</code> 可以以任何形式存储,如果有相同的 <code>key</code>那就说明有环啦</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/*** @{param} head **/</span><span class="token keyword">function</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> node <span class="token operator">=</span> head    <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">return</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 指针往下</span>            map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>next        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试必备系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack热更新原理</title>
      <link href="/2020/09/07/webpack-re-geng-xin-yuan-li/"/>
      <url>/2020/09/07/webpack-re-geng-xin-yuan-li/</url>
      
        <content type="html"><![CDATA[<h3 id="webpack中开启热更新"><a href="#webpack中开启热更新" class="headerlink" title="webpack中开启热更新"></a>webpack中开启热更新</h3><p>热更新主要是引用 <code>webpack</code> 中的内置 <code>HotModuleReplacementPlugin</code> 模块,借助 <code>webpack-dev-server</code> 这个服务中运行。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"webpack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>HotModuleReplacementPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    devServer<span class="token punctuation">:</span><span class="token punctuation">{</span>        contentBase<span class="token punctuation">:</span><span class="token string">'./dist'</span>        hot<span class="token punctuation">:</span><span class="token boolean">true</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>在 <code>package.json</code> 中配置命令 <code>&quot;dev&quot;: &quot;webpack-dev-server --config webpack.dev --open&quot;</code> 这条命令会在本地开启一个node服务。 开启编译 。<br>在 <code>node server</code> 中引入 <code>webpack-dev-middlerware</code> 和 <code>webpack-hot-middleware</code>插件。如果是koa则引入相对应的 <code>koa-webpack-dev-middlerware</code> 和 <code>koa-webpack-hot-middleware</code></p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 热更新原理 </tag>
            
            <tag> 热更新配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个大文件上传</title>
      <link href="/2020/07/15/shi-xian-yi-ge-da-wen-jian-shang-chuan/"/>
      <url>/2020/07/15/shi-xian-yi-ge-da-wen-jian-shang-chuan/</url>
      
        <content type="html"><![CDATA[<p>大文件上传实际上就是靠 <code>js</code> 中的 <code>Blob</code> 中的 <code>slice()</code> 方法把一个大文件切割成小块,再由服务端将这种小块用 <code>流</code>合并成一个新的文件。期间考虑文件改变的话就是让整个文件进行一次 <code>hash</code> 处理。加上 <code>web-worker</code>的加持让 <code>js</code> 主线程的压力降到最小。</p><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/qiYuei/upload-demo">实现大文件上传 Demo</a></p><h4 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h4><blockquote><p>vue+elementUI+spark-md5(处理文件 hash)+koa2</p></blockquote><h4 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h4><ul><li><p>前端</p><blockquote><p>cd /file-upload</p></blockquote><blockquote><p>npm i</p></blockquote><blockquote><p>npm run serve</p></blockquote></li><li><p>服务端</p><blockquote><p>cd /server</p></blockquote><blockquote><p>npm i</p></blockquote><blockquote><p>nodemon ./app.js</p></blockquote></li></ul><h4 id="功能包括"><a href="#功能包括" class="headerlink" title="功能包括"></a>功能包括</h4><ul><li>worker 进程对文件 md5 处理</li><li>限制并发请求</li><li>断点续传</li><li>秒传</li><li>错误重试</li></ul><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><pre class=" language-js"><code class="language-js">Blob<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 文件分割  用法跟分割字符串一样</span><span class="token comment" spellcheck="true">// 开启一个worker线程</span><span class="token comment" spellcheck="true">/* *  Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。 *  在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。 */</span><span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 主线程向worker线程传递数据</span>worker<span class="token punctuation">.</span><span class="token function">onpostMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 主线程监听woker线程回传数据</span>worker<span class="token punctuation">.</span><span class="token function">onmessage</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 接收一个回调</span><span class="token comment" spellcheck="true">// 服务端</span>fse<span class="token punctuation">.</span><span class="token function">existsSync</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//同步读取某个路径的文件或者文件夹是否存在 返回true或false</span>fse<span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 移动路径所在的文件</span>fse<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建一个可写流</span>fse<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建一个可读流</span>ReadStream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//  创建一个管道 将可读流的数据写入 可写流</span></code></pre><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://juejin.im/post/6844904046436843527#heading-23" target="_blank" rel="noopener">字节跳动面试官：请你实现一个大文件上传和断点续传</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 大文件上传 </tag>
            
            <tag> 断点续传 </tag>
            
            <tag> 并发处理 </tag>
            
            <tag> 错误重试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个并发限制方法</title>
      <link href="/2020/07/15/shi-xian-yi-ge-bing-fa-xian-zhi-fang-fa/"/>
      <url>/2020/07/15/shi-xian-yi-ge-bing-fa-xian-zhi-fang-fa/</url>
      
        <content type="html"><![CDATA[<img src="/2020/07/15/shi-xian-yi-ge-bing-fa-xian-zhi-fang-fa/1.png" class><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>这道题应该是很久上半年,头条的一个面试题了。这里如果单纯的用 <code>Promise.all()</code> 去处理全部的异步请求实际上会出现卡顿的情况。比如在 <code>chrome</code> 中同一时间最多支持 <code>6</code>个 <code>tcp</code>连接。</p><h3 id="浏览器与服务器建立一个-TCP-连接后，是否会在完成一个-http-请求后断开？什么条件下会断开？"><a href="#浏览器与服务器建立一个-TCP-连接后，是否会在完成一个-http-请求后断开？什么条件下会断开？" class="headerlink" title="浏览器与服务器建立一个 TCP 连接后，是否会在完成一个 http 请求后断开？什么条件下会断开？"></a>浏览器与服务器建立一个 TCP 连接后，是否会在完成一个 http 请求后断开？什么条件下会断开？</h3><p>在 <code>HTTP/1.0</code> 中，一个 <code>http</code> 请求收到服务器响应后，会 <code>断开对应的TCP连接</code> 。这样每次请求，都需要重新建立 TCP 连接，这样一直重复建立和断开的过程，比较耗时。所以为了充分利用 TCP 连接，可以设置头字段 <code>Connection: keep-alive</code> ，这样 <code>http</code> 请求完成后，就 <code>不会断开当前的TCP连接</code>，后续的 http 请求可以使用当前 TCP 连接进行通信。</p><h3 id="一个-TCP-连接可以同时发送几个-HTTP-请求？"><a href="#一个-TCP-连接可以同时发送几个-HTTP-请求？" class="headerlink" title="一个 TCP 连接可以同时发送几个 HTTP 请求？"></a>一个 TCP 连接可以同时发送几个 HTTP 请求？</h3><p>尽管这样 <code>HTTP/1.1</code> 中，<code>单个TCP连接</code>，在同一时间只能处理<code>一个http请求</code>，虽然存在 Pipelining 技术支持多个请求同时发送，但由于实践中存在很多问题无法解决，所以浏览器默认是关闭，<code>所以可以认为是不支持同时多个请求</code>。<br><code>HTTP2提供了多路传输功能，多个http请求，可以同时在同一个TCP连接中进行传输。</code></p><h3 id="浏览器-http-请求的并发性是如何体现的？并发请求的数量有没有限制？"><a href="#浏览器-http-请求的并发性是如何体现的？并发请求的数量有没有限制？" class="headerlink" title="浏览器 http 请求的并发性是如何体现的？并发请求的数量有没有限制？"></a>浏览器 http 请求的并发性是如何体现的？并发请求的数量有没有限制？</h3><p>页面资源请求时，浏览器会同时和服务器建立多个 TCP 连接，在同一个 TCP 连接上顺序处理多个 HTTP 请求。所以浏览器的并发性就体现在可以建立多个 TCP 连接，来支持多个 http 同时请求。<br>Chrome 浏览器最多允许对同一个域名 Host 建立 6 个 TCP 连接，不同的浏览器有所区别。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>url 的地址全部存放至一个数组中</li><li>通过 max 来控制最大并发度</li><li>全部请求结束后,在执行 callback 回调</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">sendRequest</span><span class="token punctuation">(</span>urls<span class="token punctuation">,</span> max<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> len <span class="token operator">=</span> urls<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token keyword">let</span> finished <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 已完成多少</span>  <span class="token keyword">const</span> request <span class="token operator">=</span> <span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>urls<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> url <span class="token operator">=</span> urls<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 取出第0个</span>      <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token keyword">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          finished<span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 完成一个请求补一个</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>finished <span class="token operator">===</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 说明执行完了</span>      <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> max<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 一执行这个函数就发送max个请求</span>    <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h3><p>按照上面的要求再加入一个需求,就是失败的请求自动请求 3 次如果三次错误的话就把错误信息放入结果中。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">sendRequest</span><span class="token punctuation">(</span>urls<span class="token punctuation">,</span> max<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> len <span class="token operator">=</span> urls<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token keyword">let</span> currentUrl <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> finished <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> request <span class="token operator">=</span> <span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> ind <span class="token operator">=</span> index <span class="token operator">||</span> currentUrl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果index 有值则说明</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ind <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">fetch</span><span class="token punctuation">(</span>urls<span class="token punctuation">[</span>ind<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          result<span class="token punctuation">[</span>ind<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保证顺序问题</span>          finished<span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>finished <span class="token operator">===</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token string">"Jieguo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 记录重试第几次</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">[</span>ind<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 有值说明已经失败过了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">[</span>ind<span class="token punctuation">]</span> <span class="token operator">></span> max <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// 这里是3 说明执行之前已经发送三次了 这次是第四次</span>              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"我已经失败三次了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              result<span class="token punctuation">[</span>ind<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token template-string"><span class="token string">`e+e`</span></span><span class="token punctuation">;</span>              finished<span class="token operator">++</span><span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>finished <span class="token operator">===</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token string">"Jieguo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>              result<span class="token punctuation">[</span>ind<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>              <span class="token function">request</span><span class="token punctuation">(</span>ind<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            result<span class="token punctuation">[</span>ind<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token function">request</span><span class="token punctuation">(</span>ind<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">!</span>index <span class="token operator">&amp;&amp;</span> currentUrl<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 没有index 说明是正常走</span>    <span class="token comment" spellcheck="true">// 有index  则是错误重试 他的currentUrl 不需要增加</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> max<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在控制并发数的同时，每结束一个请求并发起一个新的请求。依旧使用递归的方式，但这次添加一个请求队列，然后我们只要维护这个队列，不管是是否可重试,只需要结束一个请求的同时再加入一个请求。这样这个队里的请求就不会超过 <code>max</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 手写系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Promise </tag>
            
            <tag> 并发限制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解二叉树</title>
      <link href="/2020/07/09/10-fen-zhong-liao-jie-er-cha-shu/"/>
      <url>/2020/07/09/10-fen-zhong-liao-jie-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。<br>二叉树是n个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树。当集合为空时，称该二叉树为空二叉树。在二叉树中，一个元素也称作一个结点</p><blockquote><p>总结出来也就是以下几个特性<br> 子节点不能超过两个<br> 必须要有一个根节点<br> 比根小的树永远在左边,比根大的数永远在右边</p></blockquote><h2 id="构造出节点"><a href="#构造出节点" class="headerlink" title="构造出节点"></a>构造出节点</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 构建一个节点</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data        <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left        <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="构造出二叉树"><a href="#构造出二叉树" class="headerlink" title="构造出二叉树"></a>构造出二叉树</h2><p>既然是树,那必须要有一个根节点。每一个节点都需要用到上面<code>Node</code>来保证每一个节点的结构一致。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">BST</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// if (!this.root) { // 传入一个根节点</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这样我们构造出来的树大概就是这样</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//       root</span><span class="token comment" spellcheck="true">//  null       null</span></code></pre><h2 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h2><p>增加节点其实就是遍历树中的节点,其中如果目标值比节点值小就把指针指向节点的左树,直到找出空节点位置</p><pre class=" language-js"><code class="language-js"><span class="token function">insert</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 把每个传进来的数据都构建成节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> current <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root            <span class="token keyword">let</span> parent <span class="token operator">=</span> <span class="token keyword">null</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent <span class="token operator">=</span> current <span class="token comment" spellcheck="true">// 保存当前循环的节点  添加节点时 它就是父节点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>data <span class="token operator">></span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 当前节点 的值大于 需要插入的 说明要插入到左节点</span>                    current <span class="token operator">=</span> current<span class="token punctuation">.</span>left <span class="token comment" spellcheck="true">// 所以 下次循环的指针是 当前节点的左节点</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        parent<span class="token punctuation">.</span>left <span class="token operator">=</span> n                        <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//循环出口</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    current <span class="token operator">=</span> current<span class="token punctuation">.</span>right                    <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        parent<span class="token punctuation">.</span>right <span class="token operator">=</span> n                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><pre class=" language-js"><code class="language-js">    <span class="token function">mid</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 先遍历 左节点->parent->右节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">mid</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token string">'当前节点'</span><span class="token punctuation">)</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">mid</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><pre class=" language-js"><code class="language-js"><span class="token function">front</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// parent -> 左 -> 右</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token string">'当前节点'</span><span class="token punctuation">)</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><pre class=" language-js"><code class="language-js"><span class="token function">after</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 左 -> 右 -> parent </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token string">'当前节点'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="查找树中某个节点"><a href="#查找树中某个节点" class="headerlink" title="查找树中某个节点"></a>查找树中某个节点</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 查找某个节点</span>    <span class="token function">find</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> current <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root        <span class="token keyword">while</span> <span class="token punctuation">(</span>current<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>data <span class="token operator">></span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>                current <span class="token operator">=</span> current<span class="token punctuation">.</span>left            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>data <span class="token operator">&lt;</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>                current <span class="token operator">=</span> current<span class="token punctuation">.</span>right            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> current            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token punctuation">}</span></code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 删除</span>    <span class="token function">remove</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> current <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root        <span class="token keyword">let</span> parent <span class="token operator">=</span> <span class="token keyword">null</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>current<span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent <span class="token operator">=</span> current            <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>data <span class="token operator">></span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>                current <span class="token operator">=</span> current<span class="token punctuation">.</span>left            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>data <span class="token operator">&lt;</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>                current <span class="token operator">=</span> current<span class="token punctuation">.</span>right            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 这里就找到了这个节点         </span>                <span class="token keyword">let</span> left <span class="token operator">=</span> current<span class="token punctuation">.</span>left  <span class="token comment" spellcheck="true">// 保存当前节点 的左右孩子 </span>                <span class="token keyword">let</span> right <span class="token operator">=</span> current<span class="token punctuation">.</span>right                parent<span class="token punctuation">.</span>data <span class="token operator">=</span> left<span class="token punctuation">.</span>data  <span class="token comment" spellcheck="true">// 如果被删除的节点有左右孩子</span>                parent<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span>       <span class="token comment" spellcheck="true">//  则删除后 父节点的孩子就是被删除节点的孩子</span>                parent<span class="token punctuation">.</span>right <span class="token operator">=</span> right                <span class="token keyword">return</span> parent            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token punctuation">}</span></code></pre><h2 id="寻找最大值"><a href="#寻找最大值" class="headerlink" title="寻找最大值"></a>寻找最大值</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 寻找最大值</span>    <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> current <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root        <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            current <span class="token operator">=</span> current<span class="token punctuation">.</span>right        <span class="token punctuation">}</span>        <span class="token keyword">return</span> current<span class="token punctuation">.</span>data    <span class="token punctuation">}</span></code></pre><h2 id="寻找最小值"><a href="#寻找最小值" class="headerlink" title="寻找最小值"></a>寻找最小值</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 寻找最小值</span>    <span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> current <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root        <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>            current <span class="token operator">=</span> current<span class="token punctuation">.</span>left        <span class="token punctuation">}</span>        <span class="token keyword">return</span> current<span class="token punctuation">.</span>data    <span class="token punctuation">}</span></code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BST</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>node<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>node<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>node<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>node<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">/** *                 11 *             9         12 *         8      10 */</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试必备系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> Vue源码(一)-响应式原理</title>
      <link href="/2020/07/06/vue-yuan-ma-yi-xiang-ying-shi-yuan-li/"/>
      <url>/2020/07/06/vue-yuan-ma-yi-xiang-ying-shi-yuan-li/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近也是一直学习 <code>Vue</code> 的源码,也看了许多机构解析源码的视频(大部分都是白嫖~但是珠峰讲的是真的不错)。但是光看他们讲是没用滴,我们想要提 <code>(wei)高(le)自(mian)身(shi)</code> ,则需要将他们所讲再加上我们自己的理解。形成自己对 <code>Vue</code> 不说有一套独特见解,但也需要讲得出一二。</p><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p><code>vue</code> 的入口就不说啦,在 <code>/src/core/instance/index.js</code> 中明明白白写了 <code>Vue</code> 的构造函数,然后在这里执行了化一些系列功能。今天所要探讨的相应是也在 <code>initMixin(Vue)</code> 中得到初始化。<br><code>路径 /src/core/instance/state.js</code></p><img src="/2020/07/06/vue-yuan-ma-yi-xiang-ying-shi-yuan-li/entry.png" class><p><code>没错,在调用observe(data, true /* asRootData */)  //响应式</code> 就是在把我们定义的 <code>data</code> 进行数据劫持,在劫持前Vue也有一些值得注意的优化点。</p><h3 id="Observer类"><a href="#Observer类" class="headerlink" title="Observer类"></a>Observer类</h3><p><code>路径 /src/core/observer/index.js</code></p><img src="/2020/07/06/vue-yuan-ma-yi-xiang-ying-shi-yuan-li/observe.png" class><p><code>def 函数</code>是⼀个⾮常简单的 <code>Object.defineProperty</code> 的封装，这就是为什么我在开发中输出 <code>data</code> 上对象类型的数据，会发现该对象多了⼀个 <code>__ob__</code> 的属性。</p><p> <code>调用Observer类</code> 实质上就是将 <code>data</code> 中定义的每一个 <code>key</code> 通过 <code>defineProperty</code> 来修改相对应的 <code>get</code> 和<code>set</code> 来做到所谓的数据劫持。但是道理我们都懂但是它具体是怎么做的呢？</p><img src="/2020/07/06/vue-yuan-ma-yi-xiang-ying-shi-yuan-li/newObserver.png" class><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p><code>路径 /src/core/observer/array.js</code></p><p>由于 <code>Object.defineProperty()</code> 不能够为数组进行劫持,然而数组这种数据结构又是我们日常用的最多的数据结构之一。所以<code>Vue</code> 通过修改 <code>数组原来的原型链</code> 。假如修改后的原型链为 <code>prtototype1</code> 。我们调用 <code>this.arr.push()</code> =&gt; <code>this.arr.protype1.push()</code></p><img src="/2020/07/06/vue-yuan-ma-yi-xiang-ying-shi-yuan-li/array.png" class><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p><code>路径 /src/core/observer/index.js</code></p><p>对于对象来说,有天然的 <code>Object.defineProperty</code> 加持在所以就直接就可以了。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**   * Walk through all properties and convert them into   * getter/setters. This method should only be called when   * value type is Object.   */</span>  walk <span class="token punctuation">(</span>obj<span class="token punctuation">:</span> Object<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 为每一个熟悉进行Object.defineProperty()</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>哦豁重头戏来了, <code>defineReactive()</code> 是响应式的核心方法,通过 <code>递归</code> 对每个属性进行劫持,这也是这个 <code>Vue2.x</code> 的一个的缺点吧。在层级深的情况下，这里花费的时间就很长</p><img src="/2020/07/06/vue-yuan-ma-yi-xiang-ying-shi-yuan-li/defineReactive.png" class><img src="/2020/07/06/vue-yuan-ma-yi-xiang-ying-shi-yuan-li/get.png" class><img src="/2020/07/06/vue-yuan-ma-yi-xiang-ying-shi-yuan-li/set.png" class><p>够成响应式中不可缺少的就是 <code>watcher</code> 和 <code>dep</code> 这一观察者模式的最佳体现。<code>this.name</code> 则会触发 <code>name</code>属性的 <code>get</code> 而在每一次触发 <code>get</code> 都会 <code>new Dep()</code> 记录下这种依赖方式。 当 <code>this.name = xxxx</code> 时则会触发 <code>name</code> 属性的 <code>set</code> 而每次触发 <code>set</code> 都会 <code>dep.notify()</code> 来通知这个值依赖的地方 进行视图更新。</p><h3 id="Watcher类"><a href="#Watcher类" class="headerlink" title="Watcher类"></a>Watcher类</h3><p>未完待续</p><h3 id="dep类"><a href="#dep类" class="headerlink" title="dep类"></a>dep类</h3><img src="/2020/07/06/vue-yuan-ma-yi-xiang-ying-shi-yuan-li/dep.png" class>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 响应式 </tag>
            
            <tag> Vue2.x源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从URL到页面展示发生了什么</title>
      <link href="/2020/06/18/cong-url-dao-ye-mian-zhan-shi-fa-sheng-liao-shi-me/"/>
      <url>/2020/06/18/cong-url-dao-ye-mian-zhan-shi-fa-sheng-liao-shi-me/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这道面试题其实5 6句话就能搞定,难就难在这个问题能在繁衍出其他的子问题,不管是<code>计算机网络</code>还是<code>浏览器工作原理</code>还有<code>优化方面</code>都可以从这个问题拓展出。</p><blockquote><p>1.DNS 解析:将域名解析成 IP 地址<br>2.TCP 连接：TCP 三次握手<br>3.发送 HTTP 请求<br>4.服务器处理请求并返回 HTTP 报文<br>5.浏览器解析渲染页面，构建dom树，样式树，渲染树，layout布局，painting绘制<br>6.断开连接：TCP 四次挥手</p></blockquote><h1 id="网络篇"><a href="#网络篇" class="headerlink" title="网络篇"></a>网络篇</h1><h2 id="讲讲DNS解析出Ip地址的大致过程"><a href="#讲讲DNS解析出Ip地址的大致过程" class="headerlink" title="讲讲DNS解析出Ip地址的大致过程"></a>讲讲DNS解析出Ip地址的大致过程</h2><h3 id="DNS是什么"><a href="#DNS是什么" class="headerlink" title="DNS是什么"></a>DNS是什么</h3><p>「官方解释」：<code>DNS（Domain Name System，域名系统）</code>，因特网上作为「域名和IP地址相互映射」的一个「分布式数据库」，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。<br>「通俗的讲」，我们更习惯于记住一个网站的名字，比如<code>www.baidu.com</code>,而不是记住它的ip地址，比如：<code>167.23.10.2</code>。</p><h3 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h3><img src="/2020/06/18/cong-url-dao-ye-mian-zhan-shi-fa-sheng-liao-shi-me/dns.png" class><p>我们通常是通过域名访问比如百度<code>www.baidu.com</code>,首先浏览器会查看本地的浏览器缓存中有没有该域名的<code>Ip</code>。如果没有则会访问计算机的<code>.host文件</code>查看是否有相对于记录。如果在没有那就没得办法了,<code>[浏览器会发送一个请求到本地dns服务器,这个服务器一般都是我们的运营商中国移动那些..]</code>如果本地的<code>dns</code>也没有,<code>[本地dns服务器会发送一个请求至域名的根服务器]</code>例如<code>www.baidu.com</code>中就是像<code>.com</code>这个<code>根服务器</code>查询。没有则会向<code>baidu.com</code>这个<code>域服务器</code>中查询！这一过程是<code>递归查询</code>。值得注意的是无论是<code>根服务器</code>还是<code>域服务器</code>都不会直接与<code>客户端</code>通信。而是与<code>本地dns</code>通信。查询出对应得<code>ip</code>后本地的<code>dns服务器</code>会其进行缓存。</p><h2 id="我在东莞发一个请求-怎么让远在黑龙江的服务器接收"><a href="#我在东莞发一个请求-怎么让远在黑龙江的服务器接收" class="headerlink" title="我在东莞发一个请求,怎么让远在黑龙江的服务器接收"></a>我在东莞发一个请求,怎么让远在黑龙江的服务器接收</h2><p>标识网络中的一台计算机，一般至少有三种方法，最常用的是<code>域名地址</code>、<code>IP地址</code>和<code>MAC地址</code>，分别对应<code>应用层、网络层、物理层</code>。网络管理一般就是在网络层针对<code>IP地址</code>进行管理，但由于一台计算机的IP地址可以由<code>用户自行</code>设定，管理起来相对困难，<code>MAC地址</code>一般不可更改，所以把IP地址同MAC地址组合到一起管理就成为常见的管理方式。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>物理层，顾名思义，通过物理手段 ( 网线，光纤，无线 ) 将设备连接在一起，传输0/1电信号 ( 也叫比特流 ) ，就像我们上边讲到的计算机之间的物理连线<br>主要用来传输0/1信号，因为0/1信号没有任何的现实意义，所以用另一层用来规定不同0/1组合的意义</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><p><code>010101010101111000111011010</code>，像这么一串数据计算机并不知道是什么意思下层的物理层不能规定不同0/1组合的信号代表<br>什么意义，所以在数据链路层规定了一套协议，专门给<code>0/1</code>信号进行分组，规定不同的组代表的是什么意思，从而让双方计算机都<br>能够进行识别，这个协议就是我们常说的 以太网协议。但是把一台计算机的数据通过物理层和数据链路层发送给另外一台计算机，<br>怎么标识对方以及怎么知道对方的地址呢？ 唯一标示<code>MAC</code>地址 出现了</p><h4 id="Mac地址"><a href="#Mac地址" class="headerlink" title="Mac地址"></a>Mac地址</h4><p><code>Mac地址实际上就是电脑中网卡的物理地址</code>,由制造商写入网卡中的<code>bios</code>中MAC地址通常表示为<code>12个16</code>进制数，每2个16进制数之间用冒号隔开，如：<code>08:00:20:0A:8C:6D</code>就是一个MAC地址，其中前6位16进制数<code>08:00:20</code>代表网络硬件制造商的编号，它由IEEE分配，而后6位16进制数<code>0A:8C:6D</code>代表该制造商所制造的某个网络产品（如网卡）的系列号。每个网络制造商必须确保它所制造的每个以太网设备都具有相同的前三字节以及不同的后三个字节。这样就可保证世界上每个以太网设备都具有唯一的MAC 地址。<br>但是如何知道对应服务器的MAC地址呢？ 这时候<code>ip协议</code>就出来了</p><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><img src="/2020/06/18/cong-url-dao-ye-mian-zhan-shi-fa-sheng-liao-shi-me/guangbo.png" class><p>在同一子网络，就是我们常说的局域网中，计算机通过广播来通信，即向同子网中全部计算机发送数据包，其它计算机根据数据包中接收者的 MAC地址 来判断是否接收数据包<br>通俗来讲，就是A会同时给B/C/D发送数据包，这个数据包中会包含着接收者的 MAC地址 信息，当B/C/D接收到了数据包，会取出数据包中的 MAC地址 与自身的 MAC地址 对比，如相同就接收这个数据包，否则就丢弃这个数据包 (  丢包 )，这种方式我们称之为 广播<br>就像，你和女友在人群中走散了，你大喊一声她的名字，听到的人会自己匹配，是自己就会理会，不是自己就当你是傻子不理你<br>那么到了目前，我们知道了计算机之间的标示和如何通信，但是还有一个问题，要怎么知道对方的 <code>MAC地址</code> 呢 ？这又牵出了 ARP协议 ，通过 <code>ARP协议</code> 来得知对方的 <code>MAC地址</code> ，这个协议是网络层的一个协议，所以我们暂且搁置，先接着往下看</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="Ip协议"><a href="#Ip协议" class="headerlink" title="Ip协议"></a>Ip协议</h4><p><code>ip</code>协议就是我们常说的<code>IP地址</code>,通常我们用的是<code>ipv4</code>,它由32位组成。前半部分是<code>网络部分</code>，后半部分是<code>主机名</code>。如果两个ip地址的网络部分是一样的那就说明它两处于同一子网中。但是问题了随便给两个ip。我怎么知道它的网络部分是前几位，主机又是那几位。这时候就要考我们的<code>子网掩码</code></p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>子网掩码中规定<code>网络部分</code>全部是<code>1</code>,<code>主机部分</code>全部是<code>0</code>。注意<code>全部</code>这很重要。想要判断两个ip是否处在相同的子网中，只<br>需要将两个ip地址跟子网掩码进行AND运算。如果解析结果一样则是同一子网中。<br>假设他们处在同一子网当中，计算机A要和计算机B发送数据时，我们通过是 ARP协议 来得到计算机的 MAC地址</p><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p><code>ARP协议</code> 也是通过<code>广播</code>的形式，给同一个子网中每个电脑发送一个数据包，这个数据包会包含接收者的 <code>IP地址</code>，对方收到这个数据之后，会取出 <code>IP地址</code> 与自身的对比，相同则会把自己的 MAC地址 回复给对方，否则就丢弃这个数据包，这样计算机A就知道计算机B的 <code>MAC地址</code> 了<br>可能大家会问，知道了 <code>MAC地址</code> 后，发送数据是通过广播的形式发送，询问对方的 <code>MAC地址</code> 也是通过广播的形式来发送，那其他计算机怎么知道你是要传输数据还是询问 <code>MAC地址</code> 呢？<br>其实在询问 MAC地址 的数据包里，在对方的 <code>MAC地址</code> 这儿填的是一个特殊的 <code>MAC地址</code> ，其他计算机看到这个特殊的 <code>MAC地址</code> 后，就知道<code>广播</code>是在询问了<br>如果两台计算机的 IP 不是处于同一个子网之中，这个时候我们就会把数据包发送给<code>网关</code>，然后让网关帮我们进行转发,</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>通过 <code>物理层</code> / <code>数据链路层</code> 以及 <code>网络层</code> 的互相协调，我们成功的把数据从计算机A传到了计算机B，可是计算机B里面有各式各样的应用程序，计算机是如何知道这个数据是发给哪个应用程序的呢？<br>这个时候，<code>端口</code> 就上场了，当计算机A传输给计算机B的时候，还得指定一个端口，以供特定的应用程序来接收处理，作为程序员的我们对端口就更熟悉了，端口范围：<code>0~65535</code>，其中前<code>1023</code>个端口被系统占用<br>那么也就是说，<code>传输层的功能就是建立端口到端口的通信</code>，而相比之下网络层的功能是建立主机到主机的通信</p><p>在传输层中具有两大协议也就是<code>UDP</code>和<code>TCP</code>协议</p><h2 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h2><p>物理层         <code>转化为二进制数据</code></p><p>数据链构层     </p><p>网络层         <code>ip</code></p><p>传输层         <code>Tcp/UDP协议</code></p><p>应用层         <code>HTTP/HTTPS/FTP协议</code></p><h2 id="什么时候用对称加密-什么时候时候用非对称加密"><a href="#什么时候用对称加密-什么时候时候用非对称加密" class="headerlink" title="什么时候用对称加密,什么时候时候用非对称加密"></a>什么时候用对称加密,什么时候时候用非对称加密</h2><p>客户端和服务端在商量出对称加密的字符串之前使用对称加密</p><h2 id="为什么需要三次握手和四次挥手"><a href="#为什么需要三次握手和四次挥手" class="headerlink" title="为什么需要三次握手和四次挥手"></a>为什么需要三次握手和四次挥手</h2><p>三次握手是为了确保客户端和服务端都能够正常的通信</p><p>四次挥手是确保服务端已发送完数据,并且客户端也接收完服务端发送的数据</p><h2 id="讲讲HTTP的缓存"><a href="#讲讲HTTP的缓存" class="headerlink" title="讲讲HTTP的缓存"></a>讲讲HTTP的缓存</h2><h2 id="http2-0的特点"><a href="#http2-0的特点" class="headerlink" title="http2.0的特点"></a>http2.0的特点</h2><ol><li>加载资源速度更快(相比http1.1)</li><li>多路复用<ul><li>http在同一时间，针对同一域名有请求数量的限制,如果达到最大值会出现阻塞下现象，http2.0允许发送多重请求</li></ul></li><li>二进制分针 <ul><li>http2.0会将所以传输信息分为更小的信息或帧，并对他们进行二进制编码(http1.1是明文传输)</li></ul></li></ol><h2 id="https的优点和缺点"><a href="#https的优点和缺点" class="headerlink" title="https的优点和缺点"></a>https的优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>相比http https采用信息加密，更加安全</li><li>https可认证用户和服务器，确保数据发送到正确的服务器或者客户端</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>CA证书需要费用，功能越强大的SSL证书也需要更多的钱，成本高</li><li>https的握手阶段比较费时间，延长页面加载时间</li><li>ssl需要绑定服务器ip,不能再同一个ip上绑定多个域名</li></ul><h1 id="浏览器篇"><a href="#浏览器篇" class="headerlink" title="浏览器篇"></a>浏览器篇</h1><h2 id="为什么解析JS文件的时候会阻碍DOM的解析"><a href="#为什么解析JS文件的时候会阻碍DOM的解析" class="headerlink" title="为什么解析JS文件的时候会阻碍DOM的解析"></a>为什么解析JS文件的时候会阻碍DOM的解析</h2><p>因为浏览器并不清楚这个文件是否有DOM的相关操作,如果两者一起工作优先级无法确定</p><h2 id="有什么办法能让JS异步加载"><a href="#有什么办法能让JS异步加载" class="headerlink" title="有什么办法能让JS异步加载"></a>有什么办法能让JS异步加载</h2><p>在 <code>&lt;script&gt;&lt;/script&gt;</code> 中加入 <code>async</code> 或者 <code>defer</code> 字段。 两个同时存在时，<code>defer</code> 的优先级更高</p><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p><code>async</code> 属性的脚本都在它下载结束之后立刻执行，但执行顺序不能控制，先下载完的先执行</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p><code>defer</code> 是在 <code>dom解析</code> 完成后立即执行，按照原本的顺序执行</p><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><p>CSS 不会阻塞 DOM 的 <code>解析</code> ，但会<code>阻塞 DOM 渲染</code>。</p><h2 id="导致页面重绘和回流的操作"><a href="#导致页面重绘和回流的操作" class="headerlink" title="导致页面重绘和回流的操作"></a>导致页面重绘和回流的操作</h2><p>重绘不一定会触发回流，回流一定会触发重绘</p><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>在对文字的颜色、背景颜色等操作时就会发生重绘,浏览器不需要计算元素几何，跳过回流</p><h3 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h3><ol><li>窗体，字体大小<ul><li>.增加样式表</li></ul></li><li>内容变化</li><li>class属性</li><li>offserWidth 和offsetHeight</li><li>fixed</li></ol><h2 id="怎么计算一个网站首屏的加载时间"><a href="#怎么计算一个网站首屏的加载时间" class="headerlink" title="怎么计算一个网站首屏的加载时间"></a>怎么计算一个网站首屏的加载时间</h2><h1 id="优化篇"><a href="#优化篇" class="headerlink" title="优化篇"></a>优化篇</h1><h2 id="网站的优化手段有哪些"><a href="#网站的优化手段有哪些" class="headerlink" title="网站的优化手段有哪些"></a>网站的优化手段有哪些</h2><ul><li>开启Gzip压缩,(webpack可以直接配置开启,需要后端配合/<em>nginx 需要修改响应头信息</em>/)</li><li>将CSS样式表放在body前面 JS脚本放在最后并添加 <code>async</code> 或 <code>defer</code></li><li>图片懒加载</li><li>将小图片合并成雪碧图</li><li>使用浏览器缓存(服务端添加响应头)</li><li>合并请求</li></ul><h2 id="如果我一个页面拥有大量图片-应该怎么优化"><a href="#如果我一个页面拥有大量图片-应该怎么优化" class="headerlink" title="如果我一个页面拥有大量图片,应该怎么优化"></a>如果我一个页面拥有大量图片,应该怎么优化</h2><ul><li>CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片</li><li>图片懒加载</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试必备系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-Mixin疑难点</title>
      <link href="/2020/06/03/vue-mixin-yi-nan-dian/"/>
      <url>/2020/06/03/vue-mixin-yi-nan-dian/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这个API在<code>vue</code>官方文档的解释是<code>混入</code>,字面意思就是合并对吧!!!昨天笔试了一道题,就是关于<code>mixin</code>的一些理解。这个API在一般情况下我都没用用到…如果是重复的逻辑都是单独抽取当组件使用…所以昨天那道题简直就是<code>灵魂拷问</code>当时的我就是一脸懵逼。笔试完抓紧重新翻了下<code>vue</code>文档,重新拾起这部分知识记录一下</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><img src="/2020/06/03/vue-mixin-yi-nan-dian/1.png" class><img src="/2020/06/03/vue-mixin-yi-nan-dian/2.png" class><p>就是根据上图写出输出结果。当时看了就一脸懵逼。我先还原下我当时的想法首先它在入口处添加了一个全局的<code>mixin</code>。紧接着又重新<code>new Vue()</code>实例里面也有相同的逻辑,也渲染了<code>app</code>这个组件。因为看过部分的<code>源码</code>,所以知道<code>Vue</code>内部初始化的时候是先初始化<code>mixin</code>,调用<code>beforeCreate</code>,最后在初始化一些<code>props、data、methods</code>等东西。在初始化的时候如果它有<code>mixin</code>就会合并这些内容。那问题来了既然要合并如何合并?</p><ul><li>钩子是否会合并</li><li>data中怎么合并</li><li>components/methods/directives…等的合并策略</li><li>组件和Mixin的优先级</li></ul><h4 id="关于数据对象-data"><a href="#关于数据对象-data" class="headerlink" title="关于数据对象(data)"></a>关于数据对象(data)</h4><blockquote><p>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。<br>比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。</p></blockquote><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// mixin</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token punctuation">{</span>          name<span class="token punctuation">:</span><span class="token string">'mixin'</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// app.js</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token punctuation">{</span>          name<span class="token punctuation">:</span><span class="token string">'app'</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>mixin<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'mixin'</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">{</span> name <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// => app </span></code></pre><h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><blockquote><p>钩子函数也就是生命周期,这时候Vue在处理的时候会将他们合并成一个数组,并且mixin中的钩子会比组件中的mixin优先执行</p></blockquote><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// mixin</span><span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'mixin created'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// app.js</span><span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'app created'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 执行后  mixin created -  app created</span></code></pre><h4 id="components-methods-directives…等的合并策略"><a href="#components-methods-directives…等的合并策略" class="headerlink" title="components/methods/directives…等的合并策略"></a>components/methods/directives…等的合并策略</h4><blockquote><p>值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</p></blockquote><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// mixin</span>methods<span class="token punctuation">:</span><span class="token punctuation">{</span>   <span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'mixin click'</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// app</span>mixin<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'mixin'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>methods<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'app click'</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//=> app click</span></code></pre><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><p>有了这些储备知识,开始尝试重新做那道题</p><pre class=" language-js"><code class="language-js"><span class="token string">'我是mixin 的beforeCreate'</span><span class="token string">'我是mixin 的data'</span><span class="token string">'我是mixin 的beforeCreate'</span><span class="token string">'我是app 的beforeCreate'</span><span class="token string">'我是app 的data'</span><span class="token string">'我是mixin 的data'</span><span class="token string">'我是mixin 的mounted'</span><span class="token string">'我是app 的mounted'</span><span class="token string">'我是mixin 的mounted'</span></code></pre><p>首先是全局的<code>mixin</code>在<code>new Vue()</code>的时候会执行一次,控制台输出</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// '我是mixin 的beforeCreate'</span><span class="token comment" spellcheck="true">// '我是mixin 的data'</span></code></pre><p>然后在<code>new Vue()</code>的时候有一个<code>render()函数</code>,根据创建周期<code>父created-&gt;子created-&gt;子mounted-&gt;父mounted</code>的流程所以会进入到<code>APP</code>组件打印`</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// '我是mixin 的beforeCreate'</span><span class="token comment" spellcheck="true">// '我是app 的beforeCreate'</span></code></pre><p>这是因为<code>引入的是全局Mixin</code>这就相当于每个组件都会加载这个<code>Mixin</code>。紧接着就是</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// '我是app 的data'</span><span class="token comment" spellcheck="true">// '我是mixin 的data'</span></code></pre><p>下面就会进入正常的子组件挂载</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// '我是mixin 的mounted'</span><span class="token comment" spellcheck="true">// '我是app 的mounted'</span></code></pre><p>最后打印,这个别忘了!!! 这是在初始化的时候也就是在<code>new Vue()</code>的时期还未执行的钩子函数</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// '我是mixin 的mounted'</span></code></pre><p>其实在这里就可以得出<code>Mixin</code>在挂载在全局上的副作用有多大！</p><h3 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h3><p>我认为遇到一个问题不能单单只是表面上解决就完事了,还要深入源码中学习是如何判断这些优先级以及合并操作的。这样才能够提高自身。而不是单纯的做一个码农…毕竟咱是以进<code>大厂</code>为目标的。</p><p>首先找到全局定义的<code>Mixin</code>,文件位置在<code>vue/src/core/global-api/mixin.js</code></p><img src="/2020/06/03/vue-mixin-yi-nan-dian/3.png" class><p>这里很明显首先<code>this.options</code>就是<code>Vue</code>上面的<code>options</code>也就是<code>new Vue({})</code>传递的参数,先吧这个先合并是为了在<code>new Vue()</code>的时候就执行<code>Mixin里面的钩子</code>。这里就一个合并函数路径在<code>vue/src/core/util/options.js</code></p><img src="/2020/06/03/vue-mixin-yi-nan-dian/4.png" class><p>重点的地方已经加上注释,其中<code>strats</code>这个对象设置的是非常的妙从<code>传递的key</code>去执行不同的策略</p><img src="/2020/06/03/vue-mixin-yi-nan-dian/5.png" class><h4 id="合并生命周期"><a href="#合并生命周期" class="headerlink" title="合并生命周期"></a>合并生命周期</h4><p><code>Mixin</code>中并不会覆盖组件的钩子,并且<code>Mixin</code>中的钩子会比组件中的优先执行</p><img src="/2020/06/03/vue-mixin-yi-nan-dian/6.png" class><p>Chrome的debugger结果示意图</p><img src="/2020/06/03/vue-mixin-yi-nan-dian/7.png" class>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mixin </tag>
            
            <tag> 源码 </tag>
            
            <tag> 灵魂拷问 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解HTTP缓存</title>
      <link href="/2020/06/02/tu-jie-http-huan-cun/"/>
      <url>/2020/06/02/tu-jie-http-huan-cun/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为一个合格的前端工程师,且以大厂为目标的程序猿,浏览器的相关工作原理使我们进行性能优化的基石。必须牢牢掌握这才能对瞬息万变的实际场景,针对性地给出实际方案,而不是各种背诵(掘金上混脸熟)的开发’军规’和性能优化常见条例。这样很难真正发现问题所在。自己也得不到实质性的提升。</p><p>HTTP缓存分为两种<code>强缓存</code>和<code>协商缓存</code>。两者的作用都是加快资源获取,提升用户体验,减少网络连接,缓解服务器的压力。还有这里的缓存是指<code>文件文件</code>!!!并不是指平时后端从服务器拿出来的数据。</p><img src="/2020/06/02/tu-jie-http-huan-cun/1.png" class><p>又到了看图说话的时候了,我们都知道我们请求文件是发送<code>get</code>请求,在发起的时候<code>浏览器</code>就回去找请求头是否开启了<code>强缓存</code>。没开启就直接进去<code>弱缓存</code>阶段了。如果开启了就回去比对<code>强缓存的标志</code>是否过期之类的,没有过期则直接读取<code>缓存</code>这时候状态码是<code>200</code>(实际上并没有发请求)！紧接着过期了,那就必须发送一个请求去服务器了。这就到了<code>弱缓存</code>阶段。这时候就会询问服务器<code>我所请求的文件是否更新了</code>如果没更新则会返回<code>304</code>告诉浏览器<code>文件没有更新</code>。更新了则返回<code>200</code>让浏览器缓存新的文件。</p><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>不需要发送网络连接给服务器,直接读取本地的缓存。缓存可以从<code>硬盘</code>或者<code>内存</code>中。这是由浏览器决定的。但是强缓存是由<code>Expires</code>、<code>Cache-control</code>、<code>Prage</code>3个属性来控制的。</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p><code>Expires</code>也就是过期时间,这里通常会设置一个时间戳<code>Tue, 02 Jun 2020 04:12:42 GMT</code>但是这个属性有严重的缺陷就是如果服务器时间跟本地时间不同的话(时区)这个字段就没有任何意义了。所以这个字段在<code>http1.1</code>是采用<code>Cache-control</code>来控制。<code>Expires</code>优先级最低</p><h4 id="Cache-control"><a href="#Cache-control" class="headerlink" title="Cache-control"></a>Cache-control</h4><p><code>Cache-control</code>这个属性是<code>http1.1</code>新增,在响应头和请求头中都可以设置。常见的属性有</p><ul><li>max-age: 单位是秒,缓存时间计算方式是距离上一次发起时间的秒数,超过间隔的秒数缓存失效</li><li>no-cache: 禁止使用强缓存</li><li>no-store: 禁止使用缓存(包括协商缓存)</li><li>private: 专用于个人的缓存,中间代理,CDN等不能缓存响应</li><li>public: 响应可以被中间代理、CDN等缓存</li><li>must-revalidate: 在缓存过期前可以使用,过期后必须向服务器验证</li></ul><h4 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h4><p><code>Pragma</code>只有一个属性值就是<code>no-cache</code>,这个属性跟<code>Cache-control</code>中的<code>no-cache</code>一样就是不使用<code>强缓存</code></p><h4 id="验证环节"><a href="#验证环节" class="headerlink" title="验证环节"></a>验证环节</h4><p>本文采用<code>express</code>作为服务端(主要<code>KOA</code>没有找到关闭<code>弱缓存</code>的方法….)还是太菜了</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>   etag<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 禁用协商缓存</span>  lastModified<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 禁用协商缓存</span>  setHeaders<span class="token punctuation">:</span> <span class="token punctuation">(</span>res<span class="token punctuation">,</span> path<span class="token punctuation">,</span> stat<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'Cache-Control'</span><span class="token punctuation">,</span> <span class="token string">'max-age=100'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 强缓存超时时间为10秒</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>express<span class="token punctuation">.</span><span class="token keyword">static</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__dirname <span class="token operator">+</span> <span class="token string">'/public'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><img src="/2020/06/02/tu-jie-http-huan-cun/3.png" class><p>第一次加载服务端的响应头中加入了<code>Cache-Control:max-age=100</code>这个字段,也就是强缓存的时间为100秒</p><img src="/2020/06/02/tu-jie-http-huan-cun/4.png" class><p>第二次加载(并不是刷新)可以明显看到<code>http</code>状态码中有<code>(from disk cache)</code>的字样。</p><p>加入<code>Pragma</code>后并把值设为<code>no-cache</code>后发现,尽管有<code>max-age</code>但是也会重新请求服务端加载文件。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当强缓存没有命中后,并且请求头中设置了<code>If-Modified-Since</code>或者<code>If-None-Match</code>的时候,就会去尝试命中协商缓存,命中后则会返回<code>304</code>状态,加载浏览器缓存,并且响应头会设置<code>Last-Modified</code>或者<code>ETag</code>属性</p><h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h4><p><code>Last-Modified/If-Modified-Since</code>两者都是代表文件的最后修改时间,在第一次请求的时候服务端会返回这个文件的最后修改时间到<code>Last-Modified</code>字段中。在客户端重新请求这个文件的时候会带上一次请求返回的<code>Last-Modified</code>字段的值添加到本次请求头中的<code>If-Modified-Since</code>中,服务端会比较<code>If-Modified-Since</code>和<code>Last-Modified</code>是否相同,相同则返回<code>304</code>读取浏览器缓存。</p><h4 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h4><p><code>ETag/If-None-Match</code>的值是一串<code>hash</code>码，代表的是一个资源的标识符，当服务端的文件变化的时候，它的<code>hash</code>码会随之改变，通过请求头中的 <code>If-None-Match</code> 和当前文件的 hash 值进行比较，如果相等则表示命中协商缓存。<code>ETag</code> 又有强弱校验之分，如果 <code>hash</code> 码是以 <code>&quot;W/&quot;</code> 开头的一串字符串，说明此时协商缓存的校验是弱校验的，只有服务器上的文件差异（根据 <code>ETag</code> 计算方式来决定）达到能够触发 <code>hash</code> 值后缀变化的时候，才会真正地请求资源，否则返回 <code>304</code> 并加载浏览器缓存。</p>]]></content>
      
      
      <categories>
          
          <category> 面试必备系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 强缓存 </tag>
            
            <tag> 弱缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2020/05/29/er-fen-cha-zhao/"/>
      <url>/2020/05/29/er-fen-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。重点是<code>有序</code></p><h3 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> binarySearch <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> begin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 开始位置</span>    <span class="token keyword">let</span> end <span class="token operator">=</span> <span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 结束位置</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> mid <span class="token operator">=</span> begin <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span>begin<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 刚好命中</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 目标值在 mid 下标左边</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 目标值在 mid 下标右边</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 没找到的情况</span><span class="token punctuation">}</span></code></pre><p>事实上 二分法的结构就是这么简单,主要是<code>边界情况的处理</code></p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> binarySearch <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>   <span class="token keyword">let</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">let</span> end <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token comment" spellcheck="true">// 这里是最后 数组的长度相当于 0 - 最后</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 这里就必须 start &lt; 数组长度 也不能等于 </span>      <span class="token keyword">let</span> mid <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">===</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> mid      <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>          end <span class="token operator">=</span> mid<span class="token number">-1</span>      <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>          start <span class="token operator">=</span> mid <span class="token operator">+</span><span class="token number">1</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span></code></pre><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><blockquote><p> 给定一个按照升序排列的整数数组 nums ，和一个目标值 target 。找出给定目标值在数组中的开始位置和结束位置。<br> 你的算法时间复杂度必须是 O(logn) 级别。<br> 如果数组中不存在目标值，返回 [-1, -1] 。<br> 示例 1:<br> 输入: nums = [5,7,7,8,8,10], target = 8<br> 输出: [3,4]<br> 示例 2:<br> 输入: nums = [5,7,7,8,8,10], target = 6<br> 输出: [-1,-1]</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>先用二分查找找出一个位置,但是这个位置可能有左边重复跟右边重复的情况,所以需要再次用循环查找这种情况</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">find</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>        right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>        mid<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mid <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">===</span> target<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">></span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> i <span class="token operator">=</span> mid<span class="token punctuation">,</span>        j <span class="token operator">=</span> mid<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> i<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 搜索左边</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">===</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 搜索右边</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试必备系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承的几种方式</title>
      <link href="/2020/05/29/ji-cheng-de-ji-chong-fang-shi/"/>
      <url>/2020/05/29/ji-cheng-de-ji-chong-fang-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>面试官：说一说 JS 中的继承方式有哪些？以及各个继承方式的优缺点。<br>首先先来分析下这道面试题的考点有什么？首先是继承,继承有很多种方式基本上都离不开两个概念<code>原型</code>和<code>原型链</code>。然后就是这种继承的优缺点</p></blockquote><h3 id="课前知识"><a href="#课前知识" class="headerlink" title="课前知识"></a>课前知识</h3><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>首先每个JS对象都会有一个<code>__proto__</code>对象,而如果是一个函数的话的它的原型则是<code>prototype</code></p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>对象中的每一个<code>__proto__</code>和<code>prototype</code>都指向原型的<code>__proto__</code>,这样一来就形成了一条原型链</p><h4 id="两者间的联系"><a href="#两者间的联系" class="headerlink" title="两者间的联系"></a>两者间的联系</h4><img src="/2020/05/29/ji-cheng-de-ji-chong-fang-shi/1.png" class><p>这张图看上去第一眼就跟清明上河图一般都没有哈哈哈哈,反正我第一次看这张图是不懂。一坨一坨的很难懂。<br>那我们就来将它拆解分析。首先我们需要知道的是</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>obj<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Object<span class="token punctuation">.</span>prototype <span class="token comment" spellcheck="true">// true</span>obj<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Object<span class="token punctuation">.</span>__proto__ <span class="token comment" spellcheck="true">// false</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token comment" spellcheck="true">// true</span></code></pre><p>由上面可以得出一个结论</p><ol><li>每一个对象都有一个<code>__proto__</code>属性,而这个属性指向<code>JS</code>全局函数<code>Object</code>的<code>prototype</code>。</li><li>全局函数<code>Object</code>的<code>prototype</code>上面的<code>__proto__</code>指向原型链的终点<code>null</code><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> foo <span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">}</span><span class="token keyword">let</span> f1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token string">'小王'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">let</span> f2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token string">'小绿'</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>f1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> foo<span class="token punctuation">.</span>prototype <span class="token comment" spellcheck="true">// true</span>f2<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> foo<span class="token punctuation">.</span>prototype <span class="token comment" spellcheck="true">// true</span>f1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> f1<span class="token punctuation">.</span>constructor <span class="token comment" spellcheck="true">// false</span>f1 <span class="token operator">===</span> f2 <span class="token comment" spellcheck="true">// false</span>f1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> f2<span class="token punctuation">.</span>__proto__ <span class="token comment" spellcheck="true">// true</span>f1 <span class="token keyword">instanceof</span> <span class="token class-name">foo</span> <span class="token comment" spellcheck="true">// true</span></code></pre>上面的代码可能你一时间还看不懂。那我就上另一张神图<img src="/2020/05/29/ji-cheng-de-ji-chong-fang-shi/2.png" class>这样是不是就清楚多了呀。那我们来整理一下结论</li></ol><ul><li>通过函数<code>new</code>出来的实例,它的<code>__proto__</code>指向构造函数的<code>prototype</code></li><li><code>prototype</code>指向的就是原型对象，原型对象放的就是对象共享的属性</li><li>原型对象里有一个<code>constructor</code>属性，这个属性又指回了构造函数。<br>总结出来一句话就是<blockquote><p>构造函数的 prototype 指向原型对象，原型对象有一个 constructor 属性指回构造函数，每个构造函数生成的实例对象都有一个 proto 属性，这个属性指向原型对象。</p></blockquote><img src="/2020/05/29/ji-cheng-de-ji-chong-fang-shi/3.png" class><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3></li></ul><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age  <span class="token keyword">this</span><span class="token punctuation">.</span>play <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">dog</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span>type<span class="token punctuation">}</span>dog<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token string">'小猫'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">let</span> ccc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">dog</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">let</span> ddd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">dog</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span></code></pre><img src="/2020/05/29/ji-cheng-de-ji-chong-fang-shi/4.png" class><p>由图上的结果,我只对<code>ccc</code>实例上的<code>play</code>数组但是<code>ddd</code>实例上<code>play</code>也跟着改变了。因为两个实例使用的是同一个原型对象。</p><h4 id="最经典的call-方式"><a href="#最经典的call-方式" class="headerlink" title="最经典的call()方式"></a>最经典的call()方式</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age  <span class="token keyword">this</span><span class="token punctuation">.</span>play <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">}</span>foo<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'你要我说什么'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">dog</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">{</span>   foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">}</span><span class="token keyword">let</span> csd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">dog</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">'小李'</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token keyword">let</span> tce <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">dog</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">'小王'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>csd<span class="token punctuation">.</span>name<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>csd<span class="token punctuation">.</span>play<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">555</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tce<span class="token punctuation">.</span>play<span class="token punctuation">)</span>csd<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>tce<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><img src="/2020/05/29/ji-cheng-de-ji-chong-fang-shi/5.png" class><p>上图的结果很明显,虽然解决了使用同一个原型对象的问题。但是我们却没法调用原本加在<code>foo.prototype</code>的方法</p><h4 id="组合式"><a href="#组合式" class="headerlink" title="组合式"></a>组合式</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age  <span class="token keyword">this</span><span class="token punctuation">.</span>play <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">dog</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">{</span>     foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span>type<span class="token punctuation">}</span>dog<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token string">'小猫'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></code></pre><p>这个组合的方式很明显就是吧上面两个的方式组合起来了。但是这样相当于调用了两次<code>foo</code>造成了不必要的新能浪费</p><h4 id="组合式优化"><a href="#组合式优化" class="headerlink" title="组合式优化"></a>组合式优化</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age  <span class="token keyword">this</span><span class="token punctuation">.</span>play <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">dog</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">{</span>     foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span>type<span class="token punctuation">}</span>dog<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>  dog<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> dog<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 重新吧constructor 指向原来的dog</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试必备系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 继承 </tag>
            
            <tag> 原型链 </tag>
            
            <tag> 原型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始实现一个Promise</title>
      <link href="/2020/05/28/cong-0-kai-shi-shi-xian-yi-ge-promise/"/>
      <url>/2020/05/28/cong-0-kai-shi-shi-xian-yi-ge-promise/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在早期处理异步的方式都是采用回调函数的形式,比如<code>nodeApi</code>,多个回调中就形成了回调多层嵌套(也叫回调地狱)。后来出现的<code>generater</code>和<code>Promise</code>解决了回调地狱的问题。<br><code>Promise</code> 是 <code>JavaScript</code> 异步编程的一种流行解决方案，它的出现是为了解决 回调地狱 的问题，让使用者可以通过链式的写法去编写写异步代码，具体的用法笔者就不介绍了，大家可以参考阮一峰老师的 ES6 Promise教程。</p><h3 id="课前知识"><a href="#课前知识" class="headerlink" title="课前知识"></a>课前知识</h3><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>发布观察者模式简单的来说比如场景中有用户、代理商、总公司三种身份。用户通过下单告诉总公司我要订牛奶,总公司告诉代理商xx用户定了牛奶要给他送去。这种就形成了一种观察者的模式 由用户做为被观察者 总公司做为观察者观察用户的需求并由中间商执行用户需求。</p><blockquote><p>发布订阅模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。<br><code>Promise</code> 是基于 观察者的设计模式 实现的，<code>then</code> 函数要执行的函数会被塞入观察者数组中，当 <code>Promise</code> 状态变化的时候，就去执行观察组数组中的所有函数。</p></blockquote><h4 id="事件循环机制（EventLoop）"><a href="#事件循环机制（EventLoop）" class="headerlink" title="事件循环机制（EventLoop）"></a>事件循环机制（EventLoop）</h4><p>EventLoop主要分为<code>宏任务</code>和<code>微任务</code>两种形式。</p><p>在浏览器中<code>宏任务</code>主要分为</p><ul><li><code>setTimeOut</code></li><li><code>setInterval</code></li><li><code>ui渲染</code><br>而微任务主要有<code>Promise</code>,<code>MotationObserver</code>等<br>再来看一道经典题目<pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>最终打印为  1 3 6 4 5 2</p></blockquote></li></ul><h4 id="PromiseA-规范"><a href="#PromiseA-规范" class="headerlink" title="PromiseA+规范"></a>PromiseA+规范</h4><p><code>PromiseA+</code>规范是在<code>Promise</code>社区中应该遵循的规范。或者说遵循它的规范你所写的<code>Promise</code>才会被认可。在npm上有一个包<code>promise-aplus-tests</code>这个包中有大量的测试用例来检验是否符合此规范。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>我们在学习的过程中需要带着问题(脑子)去思考为什么我们要这样做</p><ul><li><code>Promise</code> 中是如何实现回调函数返回值穿透的？</li><li><code>Promise</code> 出错后，是怎么通过 冒泡 传递给最后那个捕获异常的函数？</li><li><code>Promise</code> 如何支持链式调用？</li><li>怎么将 <code>Promise.then</code> 包装成一个微任务？</li></ul><h3 id="一步步实现Promise"><a href="#一步步实现Promise" class="headerlink" title="一步步实现Promise"></a>一步步实现Promise</h3><h4 id="Promise三种状态"><a href="#Promise三种状态" class="headerlink" title="Promise三种状态"></a>Promise三种状态</h4><p>因为我们要遵循<code>promiseA+</code>规范所以我们就完全按照文档的描述来写</p><img src="/2020/05/28/cong-0-kai-shi-shi-xian-yi-ge-promise/status.png" class title="Promise状态规则"><p>图片的大概意思就是<code>Promise</code>有三种状态分别为<code>pending</code> 、<code>fulfilled</code> 、<code>rejected</code><br>且padding状态可以转化成<code>fulfilled</code>或者<code>rejected</code>状态<br>而<code>fulfillded</code>和<code>rejected</code>不能转换成其他状态</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> PADDING <span class="token operator">=</span> <span class="token string">'padding'</span><span class="token keyword">const</span> FULFILLED <span class="token operator">=</span> <span class="token string">'fulfilled'</span><span class="token keyword">const</span> REJECTED <span class="token operator">=</span> <span class="token string">'rejected'</span></code></pre><h4 id="executor执行器"><a href="#executor执行器" class="headerlink" title="executor执行器"></a>executor执行器</h4><p>在Promise中会都有一个<code>executor</code>它在<code>new Promise()</code>的时候就要执行,这个<code>executor</code>中还有两个回调分别是<code>resolve</code>和<code>reject</code></p><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">MyPromise</span><span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 初始化Promise</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> <span class="token keyword">null</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> PADDING <span class="token comment" spellcheck="true">// 当前的状态</span>     <span class="token comment" spellcheck="true">// 定义resolve和reject</span>     <span class="token keyword">let</span> resolve <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 是一个函数成功回调</span>     <span class="token punctuation">}</span>      <span class="token keyword">let</span> reject <span class="token operator">=</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 失败的回调</span>     <span class="token punctuation">}</span>         <span class="token keyword">try</span><span class="token punctuation">{</span>           <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 同步执行</span>       <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面的代码是不是就可以很好地解释为什么<code>new Promise(()=&gt;{ //todo... 是同步执行的 })</code>的问题啦。</p><h4 id="then-方法"><a href="#then-方法" class="headerlink" title="then()方法"></a>then()方法</h4><p>用过<code>Promise</code>的都知道会有一个<code>then()</code>方法。让我们来看下<code>PromiseA+</code>中是怎么定义这个<code>then</code>的</p><img src="/2020/05/28/cong-0-kai-shi-shi-xian-yi-ge-promise/then3.png" class title="then()参数规则"><p>首先<code>then()</code>方法一样接收两个回调<code>onFulfilled</code> 和<code>onRejected</code>。并且只有<code>status</code>的状态为<code>fulfilled</code>的时候才能执行<code>onFulfilled</code>回调,只有<code>status</code>的状态为<code>rejected</code>的时候才能执行<code>onRejected</code>回调。如果<code>padding</code>的状态说明<code>new Promise(()=&gt;{// 这里有异步方法})</code>就需要将他的回调放入一个专门的数组中等到状不为<code>padding</code>的时候再依次执行回调。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">MyPromise</span><span class="token punctuation">{</span>   <span class="token function">constructor</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 存放成功回调</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>onFulfilledCb <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true">// 存放失败回调</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCb <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true">// 定义resolve和reject</span>     <span class="token keyword">let</span> resolve <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 是一个函数成功回调</span>         <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> PADDING<span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 执行异步回调</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onFulfilledCb</span><span class="token punctuation">(</span>cb<span class="token operator">=</span><span class="token operator">></span><span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>      <span class="token keyword">let</span> reject <span class="token operator">=</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 失败的回调</span>          <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> PADDING<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onRejectedCb</span><span class="token punctuation">(</span>cb<span class="token operator">=</span><span class="token operator">></span><span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span>onRejected<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//首先判断 两个参数是不是方法 不是的话就构造成方法</span>  <span class="token comment" spellcheck="true">// 这里很妙 这里也叫透传参 下面会介绍到</span>  <span class="token keyword">typeof</span> onFulfilled <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> onFulfilled<span class="token punctuation">:</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span>val  <span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> onRejected <span class="token punctuation">:</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">throw</span> reason<span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 状态为 fulfilled </span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> FULFILLED<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 状态为 Reject </span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> REJECTED<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 状态为padding</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> PADDING<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>onFulfilledCb<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCb<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="传参透传"><a href="#传参透传" class="headerlink" title="传参透传"></a>传参透传</h4><blockquote><p> 表面意思就是 .then().then(res=&gt;{// 我依然可以接收到参数}).catch(e=&gt;{// 我可以最后再捕获错误})<br>还记得 typeof onFulfilled === ‘function’ ? onFulfilled: (val)=&gt;val 当 then 中没有传任何参数的时候，Promise 会使用内部默认的定义的方法，将结果传递给下一个 then。</p></blockquote><img src="/2020/05/28/cong-0-kai-shi-shi-xian-yi-ge-promise/then4.png" class><p>图片大概的意思就是</p><ul><li><code>then()</code>方法必须返回一个新的<code>Promise</code></li><li>用变量<code>x</code>接收<code>onFulfilled</code>、<code>onRejected</code> 参数的返回值</li><li>并且需要判断变量<code>x</code>是不是一个新的<code>Promise</code> 。则需要返回新<code>Promise</code>的<code>resolve()</code>值<br>既然这样那我们就按照它的要求来重新编写then方法<pre class=" language-js"><code class="language-js"><span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span>onRejected<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">let</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">typeof</span> onFulfilled <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> onFulfilled<span class="token punctuation">:</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span>val<span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> onRejected <span class="token punctuation">:</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">throw</span> reason<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 状态为 fulfilled </span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> FULFILLED<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 这里还要判断x 是否为Promise</span>    <span class="token function">reslovePromise</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>promise2<span class="token punctuation">,</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 状态为 Reject </span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> REJECTED<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 这里还要判断x 是否为Promise</span>    <span class="token function">reslovePromise</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>promise2<span class="token punctuation">,</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 状态为padding</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> PADDING<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>onFulfilledCb<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里还要判断x 是否为Promise</span>      <span class="token function">reslovePromise</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>promise2<span class="token punctuation">,</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCb<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里还要判断x 是否为Promise</span>     <span class="token keyword">let</span> x <span class="token operator">=</span>  <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token function">reslovePromise</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>promise2<span class="token punctuation">,</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 返回一个新的Promise</span><span class="token keyword">return</span> promise2<span class="token punctuation">}</span></code></pre>咦,好像不知不觉又解决了一个问题<blockquote><p>Promise如何实现链式调用<br>因为在then() 方法中永远返回了一个新的Promise实例 新的Promise实例上有then()方法<br>上面这一版<code>then()</code>看上去并没有上面问题。运行起来会报错,</p><img src="/2020/05/28/cong-0-kai-shi-shi-xian-yi-ge-promise/err.png" class><p>这是因为在new 过程中并没有 并没有还没有定义promise2这个变量 所以就会报这个错误<br>在这里应该是需要引入一个微任务来包裹 比如 <code>process.nextTick</code>、<code>MutationObserver</code>、<code>postMessage</code><br>这里暂且用setTimeOut包裹看下效果</p></blockquote><pre class=" language-js"><code class="language-js"><span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span>onRejected<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">let</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">typeof</span> onFulfilled <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> onFulfilled<span class="token punctuation">:</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span>val<span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> onRejected <span class="token punctuation">:</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">throw</span> reason<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 状态为 fulfilled </span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> FULFILLED<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 这里还要判断x 是否为Promise</span>     <span class="token function">reslovePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span>x<span class="token punctuation">,</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 状态为 Reject </span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> REJECTED<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 这里还要判断x 是否为Promise</span>    <span class="token function">reslovePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span>x<span class="token punctuation">,</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span>     <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 状态为padding</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> PADDING<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>onFulfilledCb<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里还要判断x 是否为Promise</span>      <span class="token function">reslovePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span>x<span class="token punctuation">,</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span>       <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCb<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里还要判断x 是否为Promise</span>     <span class="token keyword">let</span> x <span class="token operator">=</span>  <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token function">reslovePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span>x<span class="token punctuation">,</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span>       <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 返回一个新的Promise</span><span class="token keyword">return</span> promise2<span class="token punctuation">}</span></code></pre>这样就能顺利拿到<code>promise2</code>啦。紧接着就要编写<code>reslovePromise</code>方法</li></ul><h4 id="reslovePromise"><a href="#reslovePromise" class="headerlink" title="reslovePromise()"></a>reslovePromise()</h4><img src="/2020/05/28/cong-0-kai-shi-shi-xian-yi-ge-promise/then5.png" class><p>上图主要内容有</p><ul><li><p>如果 变量<code>x</code>的值跟<code>Promise2</code>是同一个就要抛出错误(没有返回新的<code>Promise</code>)</p></li><li><p>判断<code>x</code>是不是一个<code>Promise</code>(<code>object</code>||<code>function</code>)</p><ul><li>获取<code>x.then</code>并且判断是否为<code>function</code>,不是也直接<code>resolve(x)</code><ul><li>用<code>call</code>方式执行<code>x.then()</code>方法,成功的回调为 <code>y</code> 失败的回调为 <code>r</code><ul><li>递归使用 <code>reslovePromise()</code>防止<code>x.then()</code>的结果<code>y</code>也是<code>Promise</code></li><li>如果当前<code>Promise</code>已经被<code>called</code>那就<code>return</code></li></ul></li></ul></li></ul></li><li><p><code>x</code> 不是<code>Promise</code>就直接<code>resolve(x)</code> </p><pre class=" language-js"><code class="language-js"><span class="token function">reslovePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span>x<span class="token punctuation">,</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">===</span> promise2 <span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'不能返回本身Promise,Chaining cycle detected for promise #&lt;Promise>'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> called<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">!==</span><span class="token keyword">null</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> x<span class="token operator">===</span><span class="token string">'function'</span><span class="token operator">||</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">let</span> then <span class="token operator">=</span> x<span class="token punctuation">.</span>then  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> then <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>      then<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>called<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span>         <span class="token punctuation">}</span>        called <span class="token operator">=</span> <span class="token boolean">true</span>         <span class="token function">reslovePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span>y<span class="token punctuation">,</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>called<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span>         <span class="token punctuation">}</span>        called <span class="token operator">=</span> <span class="token boolean">true</span>        <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>called<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span>         <span class="token punctuation">}</span>        called <span class="token operator">=</span> <span class="token boolean">true</span>  <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>就这样我们就完成了一个符合<code>PromiseA+</code>的<code>Promise</code>啦<del>~</del></p><h3 id="测试是否符合PromiseA-规范"><a href="#测试是否符合PromiseA-规范" class="headerlink" title="测试是否符合PromiseA+规范"></a>测试是否符合PromiseA+规范</h3><p>使用官方测试包<code>npm i promises-aplus-tests -g</code><br>编写测试脚本</p><pre class=" language-js"><code class="language-js">MyPromise<span class="token punctuation">.</span>defer <span class="token operator">=</span> MyPromise<span class="token punctuation">.</span>deferred <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">let</span> dfd <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>dfd<span class="token punctuation">.</span>promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPrmose</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>  dfd<span class="token punctuation">.</span>resolve <span class="token operator">=</span> resolve  dfd<span class="token punctuation">.</span>reject <span class="token operator">=</span> reject<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">return</span> dfd<span class="token punctuation">}</span></code></pre><img src="/2020/05/28/cong-0-kai-shi-shi-xian-yi-ge-promise/pass.png" class><p>咳咳好像全部通过了哈哈哈哈哈哈!在这里给自己点个赞赞赞</p><h3 id="catch"><a href="#catch" class="headerlink" title="catch()"></a>catch()</h3><p>之前我们已经在<code>then()</code>中实现了参数透传,聪明的是不是很容易就想到<code>catch</code>是怎么实现的了？<br>没错就是这么简单</p><pre class=" language-js"><code class="language-js"><span class="token keyword">catch</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span>onRejected<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve()"></a>resolve()</h3><p><code>resolve()</code>是一个静态方法。实际上就是创造一个<code>Promise</code>对象。创造一个微任务</p><pre class=" language-js"><code class="language-js"><span class="token keyword">static</span> <span class="token function">resolve</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="reject"><a href="#reject" class="headerlink" title="reject()"></a>reject()</h3><p><code>reject()</code>和<code>resolve()</code>一样是<code>Promise</code>的静态方法。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">static</span> <span class="token function">reject</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>  <span class="token function">reject</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h3><p><code>Promise.all()</code>是一个静态方法,它能接受一个数组,数组里面可以是任意值(包括<code>Promise</code>)。它有一个规则就是将值依次放入到新的数组中。如果遇到错误则会<code>reject()</code>并不会往下执行。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> isPromise <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> n<span class="token operator">!==</span><span class="token keyword">null</span><span class="token operator">&amp;&amp;</span><span class="token keyword">typeof</span> n <span class="token operator">===</span><span class="token string">'object'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token keyword">typeof</span> n<span class="token punctuation">.</span>then <span class="token operator">===</span> <span class="token string">'function'</span>  <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">false</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token function">all</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>     <span class="token keyword">let</span> newArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>     <span class="token keyword">const</span> forMatter <span class="token operator">=</span> <span class="token punctuation">(</span>data<span class="token punctuation">,</span>i<span class="token punctuation">,</span>flag<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>          data<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>             newArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>res <span class="token comment" spellcheck="true">// 保证 值的位置不会错</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>e<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>           newArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>res         <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>newArr<span class="token punctuation">.</span>length <span class="token operator">===</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 当新数组和原来数组长度相等的时候就表示成功了</span>          <span class="token function">resolve</span><span class="token punctuation">(</span>newArr<span class="token punctuation">)</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPromise</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token function">forMatter</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token function">forMatter</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h3><p><code>finally()</code>方法是ES9中提出,且只能在高版本中有用。是在<code>Promise</code>的<code>resolve()</code>和<code>reject()</code>之后都会执行的钩子函数。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">finally</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>  <span class="token function">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span>data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>err<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>   <span class="token function">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token keyword">throw</span> err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 手写系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Promise </tag>
            
            <tag> 链式调用 </tag>
            
            <tag> 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个new关键字</title>
      <link href="/2020/05/27/shi-xian-yi-ge-new-guan-jian-zi/"/>
      <url>/2020/05/27/shi-xian-yi-ge-new-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<h3 id="new关键字做了什么事"><a href="#new关键字做了什么事" class="headerlink" title="new关键字做了什么事"></a>new关键字做了什么事</h3><ol><li><p>创建一个新的对象</p></li><li><p>将构造函数的原型链赋值到新的对象中</p></li><li><p>构造函数中是否返回引用类型的值不是则返回创建的对象</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">myNew</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span><span class="token operator">...</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 1.创建新对象</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 2. 将构造函数的原型链赋值到新的对象中</span>obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> ctx<span class="token punctuation">.</span>prototype<span class="token comment" spellcheck="true">// 3构造函数中是否返回引用类型的值不是则返回创建的对象</span><span class="token keyword">let</span> result <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>arg<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token keyword">typeof</span> result<span class="token operator">===</span><span class="token string">'object'</span>  <span class="token operator">?</span> result <span class="token punctuation">:</span> obj <span class="token punctuation">}</span></code></pre><h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> foo <span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">}</span>foo<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'不要问我年龄,问就是18'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">const</span> newFoo <span class="token operator">=</span> <span class="token function">myNew</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span><span class="token string">'小明'</span><span class="token punctuation">)</span>newFoo<span class="token punctuation">.</span>name <span class="token comment" spellcheck="true">// 小明</span>newFoo<span class="token punctuation">.</span><span class="token function">age</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 不要问我年龄,问就是18</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 手写系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> new </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6模块和commonJS模块</title>
      <link href="/2020/05/27/es6-mo-kuai-he-commonjs-mo-kuai/"/>
      <url>/2020/05/27/es6-mo-kuai-he-commonjs-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>模块化主要有<code>AMD</code>、<code>CMD</code>、<code>commonJS</code>、<code>Es6</code></p><ul><li><code>AMD</code>是基于<code>require.js</code> 它推崇 依赖前置</li><li><code>CMD</code>是基于<code>sea.js</code> 它推崇 依赖就近</li><li><code>common.js</code>也就是服务端的模块化(node)</li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="common-js"><a href="#common-js" class="headerlink" title="common.js"></a>common.js</h4><p><code>common.js</code>的模块化规范主要用于服务端(node),它主要是通过在<code>module.exports</code>上挂载属性</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// a.js</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    i<span class="token punctuation">,</span>    add<span class="token punctuation">}</span></code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// b.js</span><span class="token keyword">const</span> <span class="token punctuation">{</span>add<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'a.js'</span><span class="token punctuation">)</span></code></pre><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><p><code>Es6</code>主要是通过<code>import export export default</code>等关键字</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// a.js</span><span class="token keyword">export</span> y <span class="token operator">=</span><span class="token number">1</span><span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">return</span> y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    add<span class="token punctuation">}</span></code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// b.js</span><span class="token keyword">import</span> <span class="token punctuation">{</span>y<span class="token punctuation">}</span><span class="token punctuation">,</span> add <span class="token keyword">from</span> <span class="token string">'a.js'</span></code></pre><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><code>common.js</code>引用的是值的拷贝,<code>es6</code>输出的是值的引用</li><li><code>common.js</code>是运行是加载,<code>es6</code>是编译时输出接口(天然支持<code>tree-shark</code>)<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// a.js</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token keyword">let</span> y <span class="token operator">=</span><span class="token number">1</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  y<span class="token operator">++</span>  <span class="token keyword">return</span> i<span class="token punctuation">.</span>a<span class="token operator">++</span><span class="token punctuation">}</span><span class="token keyword">let</span> ii <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token keyword">let</span> yy <span class="token operator">=</span><span class="token number">1</span><span class="token keyword">function</span> <span class="token function">add2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> ii<span class="token punctuation">.</span>a<span class="token operator">++</span><span class="token punctuation">}</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  i<span class="token punctuation">,</span>add<span class="token punctuation">,</span>y<span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span>  <span class="token punctuation">{</span>  ii<span class="token punctuation">,</span>add2<span class="token punctuation">,</span>yy<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// b.js</span><span class="token keyword">const</span> <span class="token punctuation">{</span>i<span class="token punctuation">,</span>y<span class="token punctuation">,</span>add<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'a.js'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// {a:1} 1</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// {a:2} 1</span><span class="token keyword">import</span> x <span class="token keyword">from</span> <span class="token string">'a.js'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>ii<span class="token punctuation">,</span>x<span class="token punctuation">.</span>yy<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// {a:1} 1</span>x<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>ii<span class="token punctuation">,</span>x<span class="token punctuation">.</span>yy<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// {a:2} 2</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> import </tag>
            
            <tag> commonJS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
